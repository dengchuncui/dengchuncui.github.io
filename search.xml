<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>10分钟了解SimbaFs解决hadoop存算分离问题</title>
    <url>/2021/04/12/10%E5%88%86%E9%92%9F%E4%BA%86%E8%A7%A3SimbaFs%E8%A7%A3%E5%86%B3hadoop%E5%AD%98%E7%AE%97%E5%88%86%E7%A6%BB%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<h3 id="一、前言"><a href="#一、前言" class="headerlink" title="一、前言"></a>一、前言</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;众所周知传统的 Apache Hadoop 的架构存储和计算是耦合在一起的, HDFS 作为其分布式文件系统也面临一些问题。如: 存储空间或者计算资源不足两者只能同时扩容、扩容效率低、额外增加成本、灵活性差等。本文会大家回顾Hadoop的传统架构来分析上述问题以及Hadoop实现存算分离的方案和DataSimba的对于Hadoop存算分离的最佳实践。</p>
<h3 id="二、Hadoop分布式文件系统-HDFS-的架构和问题"><a href="#二、Hadoop分布式文件系统-HDFS-的架构和问题" class="headerlink" title="二、Hadoop分布式文件系统(HDFS)的架构和问题"></a>二、Hadoop分布式文件系统(HDFS)的架构和问题</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;<strong>HDFS的架构:</strong><br><img src="http://hadoop.apache.org/docs/r1.0.4/cn/images/hdfsarchitecture.gif" alt="image"> </p>
<span id="more"></span>
<p>&nbsp;&nbsp;&nbsp;&nbsp;HDFS采用master/slave架构。一个HDFS集群是由一个Namenode和一定数目的Datanodes组成。   </p>
<ul>
<li>Namenode:<ol>
<li>Namenode是一个中心服务器，负责管理文件系统的名字空间(namespace)以及客户端对文件的访问</li>
<li>Namenode执行文件系统的名字空间操作，比如打开、关闭、重命名文件或目录。它也负责确定数据块到具体Datanode节点的映射。</li>
</ol>
</li>
<li>Datanode:<ol>
<li>集群中的Datanode一般是一个节点一个，负责管理它所在节点上的存储。</li>
<li>HDFS暴露了文件系统的名字空间，用户能够以文件的形式在上面存储数据。从内部看，一个文件其实被分成一个或多个数据块，这些块存储在一组Datanode上。</li>
<li>Datanode负责处理文件系统客户端的读写请求。在Namenode的统一调度下进行数据块的创建、删除和复制。</li>
</ol>
</li>
<li>Client:<ol>
<li>用户操作HDFS文件进行创建、删除、移动或重命名操作的客户端。  </li>
</ol>
</li>
</ul>
<hr>
<p> &nbsp;&nbsp;&nbsp;&nbsp;<strong>Hadoop分布式文件系统的设计目标:</strong></p>
<ul>
<li> 适合运行在通用硬件和廉价机器(commodity hardware)上的分布式文件系统</li>
<li> 机器的硬件错误常的态化,让HDFS具有错误检测和快速、自动的恢复能力是最核心的架构目标</li>
<li>数据批处理关键的在于数据访问的高吞吐量,而POSIX标准设置的很多硬性约束对HDFS应用系统不是必需的。为了提高数据的吞吐量，在一些关键方面对POSIX的语义做了一些修改。</li>
<li>HDFS应用一次写入多次读取”的文件访问简单一致性模型</li>
<li>移动计算的思想: 进行一次请求计算数据距离越近就越高效,在海量数据处理下hadoop将计算逻辑移动到存储节点。</li>
<li>数据切分成块、数据复制副本(容错)、数据副本分布策略、机架感知、副本选择等特性来保证hdfs可靠性和提高性能的关键。</li>
<li>Datanode节点周期性地向Namenode发送心跳信号、负载均衡策略、HDFS文件内容的校验和(checksum)检查保证HDFS的健壮性和可靠性。</li>
</ul>
<hr>
<p> &nbsp;&nbsp;&nbsp;&nbsp;<strong>Hadoop分布式文件系统的问题:</strong> </p>
<ul>
<li>计算存储耦合:<br>  上面说过HDFS采用移动计算的思想,计算的时候只需要将计算代码推送到存储节点上,即可在存储节点上完成数据本地化计算，Hadoop 中的集群存储节点也是计算节点。所以当存储空间或计算资源不足时，只能同时对两者进行扩容。如果用户的计算需求远远大于存储需求,此时扩容集群会造成存储的浪费,相反则计算资源被浪费。</li>
<li>扩容问题:<br>  集群节点增多,扩容成本增加,风险增加</li>
<li>HDFS性能问题:<br>  HDFS NameNode的全局锁虽然简化了锁模型降低了复杂度,但是全局锁最大的缺点就是容易产生性能瓶颈</li>
<li>HDFS成本问题:<br>  在HDFS文件系统中典型文件大小一般都在G字节至T字节,由于HDFS的副本特性一份文件至少会存储3份,这些额外的空间会带来存储成本额外的提高</li>
</ul>
<blockquote>
<p>针对上面一些问题,现在Hadoop采用存算分离的架构的方案趋势越来越明显</p>
</blockquote>
<hr>
<h3 id="三、Hadoop-实现存算分离方案"><a href="#三、Hadoop-实现存算分离方案" class="headerlink" title="三、Hadoop 实现存算分离方案:"></a>三、<strong>Hadoop 实现存算分离方案:</strong></h3><ul>
<li>方案一: Hadoop 兼容的文件系统: </li>
</ul>
<p><img src="http://dmr-blog.oss-accelerate.aliyuncs.com/hadoop%20%E5%85%BC%E5%AE%B9%E7%9A%84%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84.png" alt="image"><br>&nbsp;&nbsp;&nbsp;&nbsp;上图是Hadoop3.X 目前兼容的文件系统,支持aws s3、腾讯云 cos、阿里云 oss存储,可以看到用户在上传数据时候,需要调用对应云服务厂商的sdk进行数据的写入。下载文件也是一样的原理。不过为什么现在可以使用这种方式实现Hadoop的计算存储分离呢？  </p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;举一个例子日常生活中遇到的经历：家里带宽自从升级到100mpbs，从来不保存电影，要看直接下载，基本几分钟就好了。这在几年前不可想象。</p>
<blockquote>
<p>带宽的速度，特别是机房内带宽的速度，已经从1000mps、2000mps、10000mps，甚至100000mpbs。但是磁盘的速度基本没有太大的变化。因为硬件的变化，带来了软件架构的变化。  </p>
</blockquote>
<p>&nbsp;&nbsp;&nbsp;&nbsp;虽然方案一可以实现计算存储分离,但是基本架构上还是存在问题:虽然带宽增加,但是如果Hadoop集群机房和对应的对象存储机房距离较远,网络抖动等原因加大了传输失败的几率,还有比如判断一个目录需要多次的refs请求才能完成操作,多次请求会对性能造成影响。</p>
<ul>
<li>方案二: 云原生的Hadoop文件系统 SimbaFs:</li>
</ul>
<p><img src="https://dmr-blog.oss-cn-shanghai.aliyuncs.com/simbaFs%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F.png" alt="image"><br>&nbsp;&nbsp;&nbsp;&nbsp;上图是SimbaFs的架构,SimbaFsClient是一个java开发的jar包,兼容Hadoop文件系统，按照Hadoop FileSystem API规范来实现。主要实现了Hadoop FileSystem的list、delete、rename、mkdir等接口，而InputStream和OutputStream主要实现了对文件读写优化相的等实现(预读、缓存读、异步写、批量写、文件压缩)。SimbaFs client通过JNI (Java Native Interface) 技术转换为本地simbafs.so的调用实现相关方法,完成文件的上传/下载操作。</p>
<ul>
<li>压测情况:  </li>
</ul>
<p>&nbsp;&nbsp;&nbsp;&nbsp;由于对于读做了预读和缓存操作,对于写的操作通过异步写和批量写的优化所以SimbaFs的性能也是非常优秀的。我们在发行版本为cdh5的集群, hdfs版本为2.6做了测试。使用3台阿里云4核14g的ecs做压力测试,对象存储选择的是oss,并且保证集群节点和oss在同一机房。下面是关于create_write、open_read、rename、delete 等操作的压测结果。<br><img src="https://dmr-blog.oss-cn-shanghai.aliyuncs.com/open_read%20%E5%90%9E%E5%90%90%E9%87%8F%E5%AF%B9%E6%AF%94.png" alt="image"><br><img src="https://dmr-blog.oss-cn-shanghai.aliyuncs.com/create_write%20%E5%90%9E%E5%90%90%E9%87%8F%E5%AF%B9%E6%AF%94.png" alt="image"><br><img src="https://dmr-blog.oss-cn-shanghai.aliyuncs.com/rename%20%E5%90%9E%E5%90%90%E9%87%8F%E5%AF%B9%E6%AF%94.png" alt="image"><br><img src="https://dmr-blog.oss-cn-shanghai.aliyuncs.com/delete%20%E5%90%9E%E5%90%90%E9%87%8F%E5%AF%B9%E6%AF%94.png" alt="image"></p>
<blockquote>
<p>可以看到SimbaFs的性能在open_read、create_write、rename是远好于HDFS的</p>
</blockquote>
<h3 id="四、小节"><a href="#四、小节" class="headerlink" title="四、小节"></a>四、小节</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;本文先回顾了传统Hadoop分布式文件系统的架构和问题,以及实现Hadoop存算分离的方案,并详细介绍了DataSimba对存算分离的SimbaFs的实现原理和压测情况。最后真心希望本文对你所有帮助。</p>
]]></content>
      <categories>
        <category>大数据</category>
      </categories>
      <tags>
        <tag>Hadoop</tag>
        <tag>计算存储分离</tag>
        <tag>云原生</tag>
      </tags>
  </entry>
  <entry>
    <title>数据同步 DATAX 工作原理及源码解读</title>
    <url>/2020/10/22/%E3%80%90%E6%95%B0%E6%8D%AE%E5%90%8C%E6%AD%A5%E3%80%91DATAX%20%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86%E5%8F%8A%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB/</url>
    <content><![CDATA[<h3 id="DataX-工作原理及源码解读"><a href="#DataX-工作原理及源码解读" class="headerlink" title="DataX 工作原理及源码解读"></a>DataX 工作原理及源码解读</h3><h4 id="背景："><a href="#背景：" class="headerlink" title="背景："></a>背景：</h4><p>&nbsp;&nbsp; 最近在工作中接触到阿里的数据同步工具datax,通过其实现了一些数据源的数据同步功能,虽然在官方文档中了解其工作原理,但是还是对其如何实现的可扩展的架构,和不同数据源之间导入导出的原理比较感兴趣,查看网上的一些介绍并没有深入源码，所以闲暇时间查看了datax的主流程代码,对此做了一下总结。</p>
<span id="more"></span>
<h4 id="概述"><a href="#概述" class="headerlink" title="概述:"></a>概述:</h4><p>&nbsp;&nbsp;该文章主要内容如下:  </p>
<ul>
<li> datax 介绍</li>
<li> datax 工作原理</li>
<li> datax 如何本地调试</li>
<li> datax 源码分析</li>
<li>总结<h4 id="一、datax-介绍"><a href="#一、datax-介绍" class="headerlink" title="一、datax 介绍"></a>一、datax 介绍</h4>&nbsp;&nbsp; <strong>github</strong>: <a href="https://github.com/alibaba/DataX/blob/master/introduction.md">datax</a><br>&nbsp;&nbsp; DataX 是一个异构数据源离线同步工具，致力于实现包括关系型数据库(MySQL、Oracle等)、HDFS、Hive、ODPS、HBase、FTP等各种异构数据源之间稳定高效的数据同步功能。<br><img src="https://dmr-blog.oss-cn-shanghai.aliyuncs.com/blog/temp/datax/22.png" alt="image"><br>具体内容可以查看官方文档这里就不做多描述。<h4 id="二、datax-工作原理"><a href="#二、datax-工作原理" class="headerlink" title="二、datax 工作原理"></a>二、datax 工作原理</h4><h5 id="1-Datax核心架构图"><a href="#1-Datax核心架构图" class="headerlink" title="1. Datax核心架构图"></a>1. Datax核心架构图</h5><img src="https://dmr-blog.oss-cn-shanghai.aliyuncs.com/blog/temp/datax/23.png" alt="image"><br>&nbsp;&nbsp; 上图为官方文档的架构图,主要氛围3个大的模块分别为job、task、taskgroup</li>
<li>job：datax 每执行一个同步任务则为一个job</li>
<li>task：datax 底层原理是将一个job,根据<strong>切分策略</strong>拆分为多个task来进行并发执行,task是datax的最小执行单位。<br>例：我要同步mysql一个表的数据到hive,我的切分规则为id,假设一张表有1w条记录，我的并发设置为5,则最总会生成25个task(并发数量*5),每个任务同步400条数据。</li>
<li>taskgroup：datax内部Scheduler模块会将拆分的task进行重组合生成taskgroup,创建对应数量的线程池进行任务数据的同步,同步顺序 Reader—&gt;Channel—&gt;Writer  <h5 id="2-Datax框架执行顺序"><a href="#2-Datax框架执行顺序" class="headerlink" title="2. Datax框架执行顺序"></a>2. Datax框架执行顺序</h5>在看源码之前需要了解datax的执行顺序才能深入理解其工作原理,下面内容是在官方复制的,已经理解其内容的同学可以选择跳过。<br><img src="https://dmr-blog.oss-cn-shanghai.aliyuncs.com/blog/temp/datax/24.png" alt="image"><br>上图中，黄色表示Job部分的执行阶段，蓝色表示Task部分的执行阶段，绿色表示框架执行阶段。  <h4 id="三、datax-如何本地调试"><a href="#三、datax-如何本地调试" class="headerlink" title="三、datax 如何本地调试"></a>三、datax 如何本地调试</h4></li>
</ul>
<ol>
<li>下载datax源码到本地<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git clone https:&#x2F;&#x2F;github.com&#x2F;alibaba&#x2F;DataX.git</span><br></pre></td></tr></table></figure></li>
<li>idea 打开项目进行编译</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">clean package assembly:assembly -Dmaven.test.skip&#x3D;true</span><br></pre></td></tr></table></figure>
<p><img src="https://dmr-blog.oss-cn-shanghai.aliyuncs.com/blog/temp/datax/1.png" alt="image"><br>3. 获取启动参数<br>&nbsp;&nbsp; datax的启动命令为</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">datax.py  xxx.json</span><br></pre></td></tr></table></figure>

<p>datax.py脚本在 /datax-core/bin/datax.py中<br><img src="https://dmr-blog.oss-cn-shanghai.aliyuncs.com/blog/temp/datax/2.png" alt="image"><br>我们用编译器打开执行python脚本,代码如下</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">if __name__ &#x3D;&#x3D; &quot;__main__&quot;:</span><br><span class="line">    printCopyright()</span><br><span class="line">    parser &#x3D; getOptionParser()</span><br><span class="line">    options, args &#x3D; parser.parse_args(sys.argv[1:])</span><br><span class="line">    if options.reader is not None and options.writer is not None:</span><br><span class="line">        generateJobConfigTemplate(options.reader,options.writer)</span><br><span class="line">        sys.exit(RET_STATE[&#39;OK&#39;])</span><br><span class="line">    if len(args) !&#x3D; 1:</span><br><span class="line">        parser.print_help()</span><br><span class="line">        sys.exit(RET_STATE[&#39;FAIL&#39;])</span><br><span class="line">    &#x2F;&#x2F; 这里生成执行脚本</span><br><span class="line">    startCommand &#x3D; buildStartCommand(options, args)</span><br><span class="line">    # print startCommand</span><br><span class="line"></span><br><span class="line">    child_process &#x3D; subprocess.Popen(startCommand, shell&#x3D;True)</span><br><span class="line">    register_signal()</span><br><span class="line">    (stdout, stderr) &#x3D; child_process.communicate()</span><br><span class="line"></span><br><span class="line">    sys.exit(child_process.returncode)</span><br></pre></td></tr></table></figure>
<p>进行debug调试,获取执行datax的系统参数如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">java -server -Xms1g -Xmx1g -XX:+HeapDumpOnOutOfMemoryError -XX:HeapDumpPath&#x3D;&#x2F;Users&#x2F;dengmingrui&#x2F;temp&#x2F;DataX&#x2F;core&#x2F;src&#x2F;main&#x2F;log -Xms1g -Xmx1g -XX:+HeapDumpOnOutOfMemoryError -XX:HeapDumpPath&#x3D;&#x2F;Users&#x2F;dengmingrui&#x2F;temp&#x2F;DataX&#x2F;core&#x2F;src&#x2F;main&#x2F;log -Dloglevel&#x3D;info -Dfile.encoding&#x3D;UTF-8 -Dlogback.statusListenerClass&#x3D;ch.qos.logback.core.status.NopStatusListener -Djava.security.egd&#x3D;file:&#x2F;&#x2F;&#x2F;dev&#x2F;urandom -Ddatax.home&#x3D;&#x2F;Users&#x2F;dengmingrui&#x2F;temp&#x2F;DataX&#x2F;core&#x2F;src&#x2F;main -Dlogback.configurationFile&#x3D;&#x2F;Users&#x2F;dengmingrui&#x2F;temp&#x2F;DataX&#x2F;core&#x2F;src&#x2F;main&#x2F;conf&#x2F;logback.xml -classpath &#x2F;Users&#x2F;dengmingrui&#x2F;temp&#x2F;DataX&#x2F;core&#x2F;src&#x2F;main&#x2F;lib&#x2F;*:.  -Dlog.file.name&#x3D;grui_temp_datax_json com.alibaba.datax.core.Engine -mode standalone -jobid -1 -job &#x2F;Users&#x2F;dengmingrui&#x2F;temp&#x2F;datax.json</span><br></pre></td></tr></table></figure>
<p>通过启动参数我们可以知道，datax的主方法在<br>com.alibaba.datax.core.Engine,中并且有3个参数分别是model、jobid、job<br>我们把pyhton 脚本生成的命令加工一下放到idea中进行调试。加工后的命令如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">-Xms1g -Xmx1g -XX:+HeapDumpOnOutOfMemoryError -XX:HeapDumpPath&#x3D;&#x2F;Users&#x2F;dengmingrui&#x2F;temp&#x2F;DataX&#x2F;target&#x2F;datax&#x2F;datax&#x2F;log -Dloglevel&#x3D;info -Dfile.encoding&#x3D;UTF-8 -Ddatax.home&#x3D;&#x2F;Users&#x2F;dengmingrui&#x2F;temp&#x2F;DataX&#x2F;target&#x2F;datax&#x2F;datax -Dlogback.configurationFile&#x3D;&#x2F;Users&#x2F;dengmingrui&#x2F;temp&#x2F;DataX&#x2F;target&#x2F;datax&#x2F;datax&#x2F;conf&#x2F;logback.xml -Dlog.file.name&#x3D;s_datax_job_job_json</span><br></pre></td></tr></table></figure>
<p><img src="https://dmr-blog.oss-cn-shanghai.aliyuncs.com/blog/temp/datax/3.png" alt="image"><br><img src="https://dmr-blog.oss-cn-shanghai.aliyuncs.com/blog/temp/datax/4.png" alt="image">  </p>
<h4 id="datax-源码分析"><a href="#datax-源码分析" class="headerlink" title="datax 源码分析"></a>datax 源码分析</h4><p> 这次例子是将mysql中的数据同步到本地所以我的datax json文件内容如下</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &quot;job&quot;: &#123;</span><br><span class="line">    &quot;content&quot;: [</span><br><span class="line">      &#123;</span><br><span class="line">        &quot;reader&quot;: &#123;</span><br><span class="line">          &quot;name&quot;: &quot;mysqlreader&quot;,</span><br><span class="line">          &quot;parameter&quot;: &#123;</span><br><span class="line">            &quot;username&quot;: &quot;xxx&quot;,</span><br><span class="line">            &quot;password&quot;: &quot;xxx&quot;,</span><br><span class="line">            &quot;column&quot;: [</span><br><span class="line">                &quot;xxx&quot;,</span><br><span class="line">                &quot;xxx&quot;,</span><br><span class="line">                &quot;xxx&quot;,</span><br><span class="line">                &quot;xxx&quot;,</span><br><span class="line">                &quot;xxx&quot;,</span><br><span class="line">                &quot;xxx&quot;</span><br><span class="line">            ],</span><br><span class="line">            &quot;splitPk&quot;: &quot;id&quot;,</span><br><span class="line">            &quot;connection&quot;: [</span><br><span class="line">                &#123;</span><br><span class="line">                    &quot;table&quot;: [</span><br><span class="line">                        &quot;xxxx&quot;</span><br><span class="line">                    ],</span><br><span class="line">                    &quot;jdbcUrl&quot;: [</span><br><span class="line">                            &quot;xxxxx&quot;</span><br><span class="line">                    ]</span><br><span class="line">                &#125;</span><br><span class="line">            ]</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;,</span><br><span class="line">        &quot;writer&quot;: &#123;</span><br><span class="line">          &quot;name&quot;: &quot;txtfilewriter&quot;,</span><br><span class="line">          &quot;parameter&quot;: &#123;</span><br><span class="line">            &quot;path&quot;: &quot;&#x2F;Users&#x2F;dengmingrui&#x2F;temp&#x2F;data&quot;,</span><br><span class="line">            &quot;fileName&quot;: &quot;test&quot;,</span><br><span class="line">            &quot;writeMode&quot;: &quot;truncate&quot;,</span><br><span class="line">            &quot;dateFormat&quot;: &quot;yyyy-MM-dd&quot;,</span><br><span class="line">            &quot;fieldDelimiter&quot;: &quot;,&quot;</span><br><span class="line">          &#125;</span><br><span class="line">          </span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    ],</span><br><span class="line">    &quot;setting&quot;: &#123;</span><br><span class="line">      &quot;speed&quot;: &#123;</span><br><span class="line">        &quot;channel&quot;: 5</span><br><span class="line">       &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>代码debug 直接执行 Engine.entry(args) 方法,具体逻辑如下<br><img src="https://dmr-blog.oss-cn-shanghai.aliyuncs.com/blog/temp/datax/5.png" alt="image">  </p>
<ol>
<li>进行main方法参数提取</li>
<li>将datax的json文件转化成Configuration对象(json文件的内容直接通过这个对象可以获取到对应的属性)</li>
<li>对datax json文件做了校验</li>
<li>执行engine.start(configuration)方法</li>
</ol>
<p><strong>start()方法</strong></p>
<p><img src="https://dmr-blog.oss-cn-shanghai.aliyuncs.com/blog/temp/datax/6.png" alt="image">  </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 该方法对datax 的json配置文件做了一些填充</span><br><span class="line">ColumnCast.bind(allConf);</span><br></pre></td></tr></table></figure>
<p>该方法对datax 的json配置文件做了一些填充,填充内容如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    &quot;common&quot;:&#123;</span><br><span class="line">        &quot;column&quot;:&#123;</span><br><span class="line">            &quot;dateFormat&quot;:&quot;yyyy-MM-dd&quot;,</span><br><span class="line">            &quot;datetimeFormat&quot;:&quot;yyyy-MM-dd HH:mm:ss&quot;,</span><br><span class="line">            &quot;encoding&quot;:&quot;utf-8&quot;,</span><br><span class="line">            &quot;extraFormats&quot;:[</span><br><span class="line">                &quot;yyyyMMdd&quot;</span><br><span class="line">            ],</span><br><span class="line">            &quot;timeFormat&quot;:&quot;HH:mm:ss&quot;,</span><br><span class="line">            &quot;timeZone&quot;:&quot;GMT+8&quot;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    &quot;core&quot;:&#123;</span><br><span class="line">        &quot;container&quot;:&#123;</span><br><span class="line">            &quot;job&quot;:&#123;</span><br><span class="line">                &quot;id&quot;:-1,</span><br><span class="line">                &quot;reportInterval&quot;:10000</span><br><span class="line">            &#125;,</span><br><span class="line">            &quot;taskGroup&quot;:&#123;</span><br><span class="line">                &quot;channel&quot;:5</span><br><span class="line">            &#125;,</span><br><span class="line">            &quot;trace&quot;:&#123;</span><br><span class="line">                &quot;enable&quot;:&quot;false&quot;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,</span><br><span class="line">        &quot;dataXServer&quot;:&#123;</span><br><span class="line">            &quot;address&quot;:&quot;http:&#x2F;&#x2F;localhost:7001&#x2F;api&quot;,</span><br><span class="line">            &quot;reportDataxLog&quot;:false,</span><br><span class="line">            &quot;reportPerfLog&quot;:false,</span><br><span class="line">            &quot;timeout&quot;:10000</span><br><span class="line">        &#125;,</span><br><span class="line">        &quot;statistics&quot;:&#123;</span><br><span class="line">            &quot;collector&quot;:&#123;</span><br><span class="line">                &quot;plugin&quot;:&#123;</span><br><span class="line">                    &quot;maxDirtyNumber&quot;:10,</span><br><span class="line">                    &quot;taskClass&quot;:&quot;com.alibaba.datax.core.statistics.plugin.task.StdoutPluginCollector&quot;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,</span><br><span class="line">        &quot;transport&quot;:&#123;</span><br><span class="line">            &quot;channel&quot;:&#123;</span><br><span class="line">                &quot;byteCapacity&quot;:67108864,</span><br><span class="line">                &quot;capacity&quot;:512,</span><br><span class="line">                &quot;class&quot;:&quot;com.alibaba.datax.core.transport.channel.memory.MemoryChannel&quot;,</span><br><span class="line">                &quot;flowControlInterval&quot;:20,</span><br><span class="line">                &quot;speed&quot;:&#123;</span><br><span class="line">                    &quot;byte&quot;:-1,</span><br><span class="line">                    &quot;record&quot;:-1</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;,</span><br><span class="line">            &quot;exchanger&quot;:&#123;</span><br><span class="line">                &quot;bufferSize&quot;:32,</span><br><span class="line">                &quot;class&quot;:&quot;com.alibaba.datax.core.plugin.BufferedRecordExchanger&quot;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    &quot;entry&quot;:&#123;</span><br><span class="line">        &quot;jvm&quot;:&quot;-Xms1G -Xmx1G&quot;</span><br><span class="line">    &#125;,</span><br><span class="line">    &quot;job&quot;:Object&#123;...&#125;,</span><br><span class="line">    &quot;plugin&quot;:&#123;</span><br><span class="line">        &quot;reader&quot;:&#123;</span><br><span class="line">            &quot;mysqlreader&quot;:&#123;</span><br><span class="line">                &quot;class&quot;:&quot;com.alibaba.datax.plugin.reader.mysqlreader.MysqlReader&quot;,</span><br><span class="line">                &quot;description&quot;:&quot;useScene: prod. mechanism: Jdbc connection using the database, execute select sql, retrieve data from the ResultSet. warn: The more you know about the database, the less problems you encounter.&quot;,</span><br><span class="line">                &quot;developer&quot;:&quot;alibaba&quot;,</span><br><span class="line">                &quot;name&quot;:&quot;mysqlreader&quot;,</span><br><span class="line">                &quot;path&quot;:&quot;&#x2F;Users&#x2F;dengmingrui&#x2F;temp&#x2F;DataX&#x2F;target&#x2F;datax&#x2F;datax&#x2F;plugin&#x2F;reader&#x2F;mysqlreader&quot;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,</span><br><span class="line">        &quot;writer&quot;:&#123;</span><br><span class="line">            &quot;txtfilewriter&quot;:&#123;</span><br><span class="line">                &quot;class&quot;:&quot;com.alibaba.datax.plugin.writer.txtfilewriter.TxtFileWriter&quot;,</span><br><span class="line">                &quot;description&quot;:&quot;useScene: test. mechanism: use datax framework to transport data to txt file. warn: The more you know about the data, the less problems you encounter.&quot;,</span><br><span class="line">                &quot;developer&quot;:&quot;alibaba&quot;,</span><br><span class="line">                &quot;name&quot;:&quot;txtfilewriter&quot;,</span><br><span class="line">                &quot;path&quot;:&quot;&#x2F;Users&#x2F;dengmingrui&#x2F;temp&#x2F;DataX&#x2F;target&#x2F;datax&#x2F;datax&#x2F;plugin&#x2F;writer&#x2F;txtfilewriter&quot;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p> 可以看到我们原来配置的json内容只是整个json的job部分，其他内容都是由 ColumnCast.bind(allConf)方法补充的。后面调用了<br> 下面的方法(伪代码)</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">AbstractContainer  container &#x3D; new JobContainer(allConf);</span><br><span class="line">container.start();</span><br></pre></td></tr></table></figure>
<p><strong>JobContainer start()方法</strong>  </p>
<p><img src="https://dmr-blog.oss-cn-shanghai.aliyuncs.com/blog/temp/datax/7.png" alt="image"><br> 可以看到datax调用方法顺序如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 前置处理</span><br><span class="line"> this.preHandle();</span><br><span class="line"> &#x2F;&#x2F; 初始化</span><br><span class="line"> this.init();</span><br><span class="line"> &#x2F;&#x2F; 准备方法</span><br><span class="line"> this.prepare();</span><br><span class="line"> &#x2F;&#x2F; 任务切分  </span><br><span class="line"> this.split();</span><br><span class="line"> &#x2F;&#x2F; 执行调度</span><br><span class="line"> this.schedule();</span><br><span class="line"> &#x2F;&#x2F; ...</span><br><span class="line"> this.post();</span><br><span class="line"> &#x2F;&#x2F; ...</span><br><span class="line"> this.postHandle();</span><br><span class="line"> this.invokeHooks();</span><br></pre></td></tr></table></figure>
<p>其中核心的方法为 this.init()  、this.split()、 this.schedule() 本次重点只看这几个方法<br><strong>init()方法</strong><br><img src="https://dmr-blog.oss-cn-shanghai.aliyuncs.com/blog/temp/datax/8.png" alt="image"><br><strong>initJobReader</strong>方法<br><img src="https://dmr-blog.oss-cn-shanghai.aliyuncs.com/blog/temp/datax/9.png" alt="image"><br>通过方法将mysql插件的类家在到jvm中</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">LoadUtil.loadJobPlugin(PluginType.READER,this.readerPluginName)</span><br></pre></td></tr></table></figure>
<p>提取Configuration 对象参数的部分插入到 jobReader 的pluginJobConf 属性中,具体内容如下</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; pluginJobConf</span><br><span class="line">&#123;</span><br><span class="line">    &quot;column&quot;:[</span><br><span class="line">        &quot;id&quot;,</span><br><span class="line">        &quot;project_id&quot;,</span><br><span class="line">        &quot;alarm_time&quot;,</span><br><span class="line">        &quot;job_id&quot;,</span><br><span class="line">        &quot;job_name&quot;,</span><br><span class="line">        &quot;receiver&quot;</span><br><span class="line">    ],</span><br><span class="line">    &quot;connection&quot;:[</span><br><span class="line">        &#123;</span><br><span class="line">            &quot;jdbcUrl&quot;:[</span><br><span class="line">                &quot;xxxx&quot;</span><br><span class="line">            ],</span><br><span class="line">            &quot;table&quot;:[</span><br><span class="line">                &quot;xxxxx&quot;</span><br><span class="line">            ]</span><br><span class="line">        &#125;</span><br><span class="line">    ],</span><br><span class="line">    &quot;password&quot;:&quot;xxxxx&quot;,</span><br><span class="line">    &quot;splitPk&quot;:&quot;id&quot;,</span><br><span class="line">    &quot;username&quot;:&quot;xxxx&quot;</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F; peerPluginJobConf</span><br><span class="line">&#123;</span><br><span class="line">    &quot;dateFormat&quot;:&quot;yyyy-MM-dd&quot;,</span><br><span class="line">    &quot;fieldDelimiter&quot;:&quot;,&quot;,</span><br><span class="line">    &quot;fileName&quot;:&quot;test&quot;,</span><br><span class="line">    &quot;path&quot;:&quot;&#x2F;Users&#x2F;dengmingrui&#x2F;temp&#x2F;data&quot;,</span><br><span class="line">    &quot;writeMode&quot;:&quot;truncate&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>最终执行jobReader.init(); mysql插件的init方法进行初始化。<br>initJobWriter()逻辑类似这里就不查看了<br><strong>split()方法</strong><br>split方法是reader和writer最细粒度的切分,writer的切分结果要参照reader的切分结果达到切分后数目相等，才能满足1：1的通道模型<br><img src="https://dmr-blog.oss-cn-shanghai.aliyuncs.com/blog/temp/datax/10.png" alt="image"><br> split 方法分为3部分</p>
<ol>
<li>拆分reader </li>
<li>根据reader的拆分结果拆分writer</li>
<li>将reader 和 writer的拆分结果 合并到Configuration对象中<br>具体的拆分情况，感兴趣的同学可以看一下对应插件的源码<br>下面是我当前任务拆分后,我之前配置的json内容变成什么样子了。</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    &quot;common&quot;:Object&#123;...&#125;,</span><br><span class="line">    &quot;core&quot;:&#123;</span><br><span class="line">        &quot;container&quot;:&#123;</span><br><span class="line">            &quot;job&quot;:Object&#123;...&#125;,</span><br><span class="line">            &quot;taskGroup&quot;:&#123;</span><br><span class="line">                &quot;channel&quot;:5</span><br><span class="line">            &#125;,</span><br><span class="line">            &quot;trace&quot;:Object&#123;...&#125;</span><br><span class="line">        &#125;,</span><br><span class="line">        &quot;dataXServer&quot;:Object&#123;...&#125;,</span><br><span class="line">        &quot;statistics&quot;:&#123;</span><br><span class="line">            &quot;collector&quot;:Object&#123;...&#125;</span><br><span class="line">        &#125;,</span><br><span class="line">        &quot;transport&quot;:Object&#123;...&#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    &quot;entry&quot;:&#123;</span><br><span class="line">        &quot;jvm&quot;:&quot;-Xms1G -Xmx1G&quot;</span><br><span class="line">    &#125;,</span><br><span class="line">    &quot;job&quot;:&#123;</span><br><span class="line">        &quot;content&quot;:[</span><br><span class="line">            Object&#123;...&#125;,</span><br><span class="line">            Object&#123;...&#125;,</span><br><span class="line">            Object&#123;...&#125;,</span><br><span class="line">            Object&#123;...&#125;,</span><br><span class="line">            Object&#123;...&#125;,</span><br><span class="line">            Object&#123;...&#125;,</span><br><span class="line">            &#123;</span><br><span class="line">                &quot;reader&quot;:&#123;</span><br><span class="line">                    &quot;name&quot;:&quot;mysqlreader&quot;,</span><br><span class="line">                    &quot;parameter&quot;:&#123;</span><br><span class="line">                        &quot;column&quot;:&quot;id,xx,xx,job_id,xxx,xxx&quot;,</span><br><span class="line">                        &quot;columnList&quot;:[</span><br><span class="line">                            &quot;xxx&quot;,</span><br><span class="line">                            &quot;xxx&quot;,</span><br><span class="line">                            &quot;xxx&quot;,</span><br><span class="line">                            &quot;xxx&quot;,</span><br><span class="line">                            &quot;xxxx&quot;,</span><br><span class="line">                            &quot;xxxx&quot;</span><br><span class="line">                        ],</span><br><span class="line">                        &quot;fetchSize&quot;:-2147483648,</span><br><span class="line">                        &quot;isTableMode&quot;:true,</span><br><span class="line">                        &quot;jdbcUrl&quot;:&quot;jxxxxxx&quot;,</span><br><span class="line">                        &quot;loadBalanceResourceMark&quot;:&quot;xxxx&quot;,</span><br><span class="line">                        &quot;password&quot;:&quot;xxxxxx&quot;,</span><br><span class="line">                        &quot;pkType&quot;:&quot;pkTypeLong&quot;,</span><br><span class="line">                        &quot;querySql&quot;:&quot;select xxx,xxxx,xxxx,xxxx,xxxx,xxxx from xxxx  where  (2977 &lt;&#x3D; id AND id &lt; 3473) &quot;,</span><br><span class="line">                        &quot;splitPk&quot;:&quot;id&quot;,</span><br><span class="line">                        &quot;table&quot;:&quot;xxxx&quot;,</span><br><span class="line">                        &quot;tableNumber&quot;:1,</span><br><span class="line">                        &quot;username&quot;:&quot;xxxx&quot;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;,</span><br><span class="line">                &quot;taskId&quot;:6,</span><br><span class="line">                &quot;writer&quot;:&#123;</span><br><span class="line">                    &quot;name&quot;:&quot;txtfilewriter&quot;,</span><br><span class="line">                    &quot;parameter&quot;:&#123;</span><br><span class="line">                        &quot;dateFormat&quot;:&quot;yyyy-MM-dd&quot;,</span><br><span class="line">                        &quot;encoding&quot;:&quot;UTF-8&quot;,</span><br><span class="line">                        &quot;fieldDelimiter&quot;:&quot;,&quot;,</span><br><span class="line">                        &quot;fileName&quot;:&quot;test__ad112b06_6dd1_4708_a608_890fbf55f7b1&quot;,</span><br><span class="line">                        &quot;path&quot;:&quot;&#x2F;Users&#x2F;dengmingrui&#x2F;temp&#x2F;data&quot;,</span><br><span class="line">                        &quot;writeMode&quot;:&quot;truncate&quot;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;,</span><br><span class="line">            Object&#123;...&#125;,</span><br><span class="line">            Object&#123;...&#125;,</span><br><span class="line">            Object&#123;...&#125;,</span><br><span class="line">            Object&#123;...&#125;,</span><br><span class="line">            Object&#123;...&#125;,</span><br><span class="line">            Object&#123;...&#125;,</span><br><span class="line">            Object&#123;...&#125;,</span><br><span class="line">            Object&#123;...&#125;,</span><br><span class="line">            Object&#123;...&#125;,</span><br><span class="line">            Object&#123;...&#125;,</span><br><span class="line">            Object&#123;...&#125;,</span><br><span class="line">            Object&#123;...&#125;,</span><br><span class="line">            Object&#123;...&#125;,</span><br><span class="line">            Object&#123;...&#125;,</span><br><span class="line">            Object&#123;...&#125;,</span><br><span class="line">            Object&#123;...&#125;,</span><br><span class="line">            Object&#123;...&#125;,</span><br><span class="line">            Object&#123;...&#125;,</span><br><span class="line">            Object&#123;...&#125;</span><br><span class="line">        ],</span><br><span class="line">        &quot;setting&quot;:&#123;</span><br><span class="line">            &quot;speed&quot;:&#123;</span><br><span class="line">                &quot;channel&quot;:5</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    &quot;plugin&quot;:Object&#123;...&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看到job.content数组下面多了很多小job,这里每个小job就是我们一开始说的task,每一个task 都有对应reader和writer的数据源信息。datax这里把json完的很6<br><strong>schedule()方法</strong><br> &nbsp;&nbsp;一开始我们说过了schedule 是把拆分的结果合并到一个taskgroup中,最终执行<br><img src="https://dmr-blog.oss-cn-shanghai.aliyuncs.com/blog/temp/datax/11.png" alt="image"><br>最终调用startAllTaskGroup()发放执行taskgroup的任务<br><img src="https://dmr-blog.oss-cn-shanghai.aliyuncs.com/blog/temp/datax/12.png" alt="image"></p>
<p><img src="https://dmr-blog.oss-cn-shanghai.aliyuncs.com/blog/temp/datax/13.png" alt="image"></p>
<p>最终线程执行的方法在TaskGroupContainer累的run()方法中,这里逻辑太长了就不截图了<br><img src="https://dmr-blog.oss-cn-shanghai.aliyuncs.com/blog/temp/datax/14.png" alt="image"><br>datax 将任务最终放入到队列中，后面有一个死循环一直从队列中获取任务最终调用 taskExecutor.doStart();方法执行到真正单个task执行的逻辑<br><img src="https://dmr-blog.oss-cn-shanghai.aliyuncs.com/blog/temp/datax/15.png" alt="image">    </p>
<p><strong>doStart() 方法</strong><br> 先开启写线程，再开启读线程</p>
<p><img src="https://dmr-blog.oss-cn-shanghai.aliyuncs.com/blog/temp/datax/16.png" alt="image">  </p>
<p>readerThread 和 writerThread 是什么时候初始化的呢？<br>答：是在 new TaskExecutor()的时候, 最终读取的还是json中的plugin配置<br><img src="https://dmr-blog.oss-cn-shanghai.aliyuncs.com/blog/temp/datax/17.png" alt="image"><br>最终执行的run方法是在ReaderRunner和WriterRunner这2个类对应的run()方法<br><img src="https://dmr-blog.oss-cn-shanghai.aliyuncs.com/blog/temp/datax/18.png" alt="image">  </p>
<h5 id="reader-和-writer-之间是如何通信的呢？"><a href="#reader-和-writer-之间是如何通信的呢？" class="headerlink" title="reader 和 writer 之间是如何通信的呢？"></a>reader 和 writer 之间是如何通信的呢？</h5><p>答： Record 对象，reader 插件在读取之后，将对应的数据封装到Record对象,存储在集合中,writer 读取对应的集合数据在执行写入到目标数据源。下面是mysql插件的逻辑<br><img src="https://dmr-blog.oss-cn-shanghai.aliyuncs.com/blog/temp/datax/19.png" alt="image"><br>最终写入的方法在BufferedRecordExchanger类的sendToWriter方法<br><img src="https://dmr-blog.oss-cn-shanghai.aliyuncs.com/blog/temp/datax/20.png" alt="image"><br>读取的场景在WriterRunner类的run()方法</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">taskWriter.startWrite(recordReceiver);</span><br></pre></td></tr></table></figure>
<p><img src="https://dmr-blog.oss-cn-shanghai.aliyuncs.com/blog/temp/datax/21.png" alt="image"><br>到这里我们就把task 读写场景的核心逻辑看完了</p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>&nbsp;&nbsp;本次查看了datax的源码,对datax有了更生层次的理解,datax的插件架构还是学习到了，并且整个任务全程用json对应的Configuration类贯穿整个链路非常使得代码非常灵活。datax对任务的拆分设计和精准的速度控制逻辑的设计后面也有借鉴的地方，类加载器的使用非常巧，代码整体上还是写的非常易懂的看起来并不吃力。其实datax的架构和执行逻辑文档上写的还是很清楚的，如果感兴趣的话可以快速看一下源码的。</p>
]]></content>
      <categories>
        <category>大数据</category>
      </categories>
      <tags>
        <tag>源码</tag>
        <tag>datax</tag>
        <tag>数据同步</tag>
        <tag>大数据</tag>
      </tags>
  </entry>
  <entry>
    <title>项目规范 对于服务异常和错误码规范的总结</title>
    <url>/2020/10/02/%E9%A1%B9%E7%9B%AE%E8%A7%84%E8%8C%83%20%E5%AF%B9%E4%BA%8E%E6%9C%8D%E5%8A%A1%E5%BC%82%E5%B8%B8%E5%92%8C%E9%94%99%E8%AF%AF%E7%A0%81%E8%A7%84%E8%8C%83%E7%9A%84%E6%80%BB%E7%BB%93/</url>
    <content><![CDATA[<h3 id="服务异常和错误码规范"><a href="#服务异常和错误码规范" class="headerlink" title="服务异常和错误码规范"></a>服务异常和错误码规范</h3><h4 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h4><p>&nbsp;&nbsp;目前公司的服务端返回的异常不规范,导致接口各个场景返回的异常不统一,使得项目不好维护。并且代码看起来不优雅,目前公司项目遇到了国际化的问题,服务端的异常也需要做出相关调整。所以对服务端的异常错误码制定一个规范。</p>
<h4 id="思考"><a href="#思考" class="headerlink" title="思考"></a>思考</h4><ul>
<li>需要制定那些异常？</li>
<li>错误码如何设计？如何做到可读性、可维护、灵活可控？</li>
<li>新的异常规范,如何设计才会对当前项目侵入性小？<span id="more"></span>
<h4 id="异常分类"><a href="#异常分类" class="headerlink" title="异常分类"></a>异常分类</h4>&nbsp;&nbsp;根据之前的工作经验,异常分为两个大分类,<strong>未知异常</strong>、<strong>已知异常</strong>,结合这两个分类对异常进行拆分,直到拆分到不能拆分为止。拆分结果如下：</li>
</ul>
<p><img src="https://qingqing-test.oss-cn-qingdao.aliyuncs.com/simba/%E5%BC%82%E5%B8%B8%E5%88%86%E7%B1%BB.png" alt="image"></p>
<blockquote>
<p>异常拆分一定要结合整体服务业务,有些公司服务的异常可能其他公司永远都用不上。比如电商的项目有些异常场景可能做crm系统的永远用不上。所以不要盲目借鉴。</p>
</blockquote>
<h3 id="异常介绍"><a href="#异常介绍" class="headerlink" title="异常介绍"></a>异常介绍</h3><ul>
<li>未知异常<br>未知异常指的是服务端不可感知和控制的异常,如引入的jar包中抛出的异常,或者数据库链接异常,或者代码bug出现的空指针异常和badsql,这些异常是服务端可能出现的情况,上面列举的几个场景也确实是服务器异常,所以针对这种情况,服务端接口返回的http状态码是500 无需将相关异常栈信息返回,增加代码安全性。<blockquote>
<p>这里指的安全性是比如写了一个badsql 如果把异常栈抛出去则会导致数据表泄漏</p>
</blockquote>
</li>
<li>已知异常<br>已知异常是服务端知道可能出现异常的场景,目前拆分为<strong>前置异常</strong>、<strong>外部异常</strong>、<strong>自定义异常</strong>,对于这些异常http状态码是200,并且可以返回响应的错误信息,具体描述如下  <ol>
<li>前置异常：指的是代码还没有到真正业务逻辑前抛出的异常,比如<strong>参数校验失败异常</strong>、<strong>用户没有权限异常</strong>、<strong>token过期异常</strong>、<strong>未找到资源异常</strong> 等等，</li>
<li>外部异常：指的是因为外部因素导致的接口异常而非正常业务逻辑错误或者数据错误导致的,比如<strong>第三方服务商异常</strong>、<strong>接口被限流</strong>、<strong>接口重复请求</strong></li>
<li>自定义异常：指的是程序员自己抛出来的异常，这种异常是因为代码在相关业务逻辑中，不满足业务条件并且必须手动抛出的异常，比如:子表记录找不到对应父表的记录,这种正常逻辑是不可能存在场景,是需要手动抛出异常进行排查的并且这种问题你也没办法兼容。或者举行一个秒杀活动，在活动未开始之前就有请求到服务端了，这是不现实的情况,并且于这种场景需要以来服务端的响应作出对应的展示文案，所有服务端需要自定义相关的异常返回,前段解析相关的错误码作出相关的文案展示。对于这种异常称作自定义异常。</li>
</ol>
</li>
</ul>
<h3 id="错误码的设计"><a href="#错误码的设计" class="headerlink" title="错误码的设计"></a>错误码的设计</h3><ul>
<li><h4 id="错误码的作用"><a href="#错误码的作用" class="headerlink" title="错误码的作用"></a>错误码的作用</h4><ol>
<li>程序员根据错误码能够快速定位问题</li>
<li>通过不同的错误码可以区分出是什么原因导致的问题(传参错误，没有权限，服务异常) </li>
<li><strong>明确清晰</strong>的展示错误信息，方便程序员快速定位问题</li>
</ol>
</li>
<li><h4 id="错误码的定义"><a href="#错误码的定义" class="headerlink" title="错误码的定义"></a>错误码的定义</h4><ol>
<li>数字类型error_code标识  <ul>
<li>长度可控,节省传输带宽</li>
<li>可读性差,需要相关文档</li>
<li>数字范围分段,表示不通分类,不同业务的异常</li>
</ul>
</li>
<li>字符串类型的error_code标识<ul>
<li>长度稍长</li>
<li>可读性高,见名知意</li>
</ul>
</li>
</ol>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    &#39;error_code&#39;:401,</span><br><span class="line">    &#39;error_str_code&#39;:&#39;UnAuthorized&#39;,</span><br><span class="line">    &#39;error_msg&#39;:&#39;user un Authorized: user_id:&#123;xxx&#125;&#39;,</span><br><span class="line">    &#39;error_reason&#39;:&#39;用户未授权&#39;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><h4 id="错误码枚举伪代码"><a href="#错误码枚举伪代码" class="headerlink" title="错误码枚举伪代码"></a>错误码枚举伪代码</h4></li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public interface ErrorCodeInterface &#123;</span><br><span class="line">   </span><br><span class="line">    Integer getErrorCode();</span><br><span class="line">    </span><br><span class="line">    String getStrErrorCode();</span><br><span class="line">    </span><br><span class="line">    String getMsg();</span><br><span class="line"></span><br><span class="line">    String getReason();</span><br><span class="line">&#125;</span><br><span class="line">@AllArgsConstructor</span><br><span class="line">public enum xxxxErrorCode implements ErrorCodeInterface&#123;</span><br><span class="line">     </span><br><span class="line">    ENCODE_SDK_LICENSE_OVERDUE(1001, &quot;ActivityNotStarted&quot;, &quot;Current Activity not started&quot;,&quot;当前活动暂未开始&quot;),</span><br><span class="line">  </span><br><span class="line">    Integer errorCode;</span><br><span class="line">    String  strErrorCode;</span><br><span class="line">    String  msg;</span><br><span class="line">    String reason ;</span><br><span class="line">    @Override</span><br><span class="line">    public Integer getErrorCode() &#123;</span><br><span class="line">        return errorCode;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    @Override</span><br><span class="line">    public String getMsg() &#123;</span><br><span class="line">        return msg;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public String getStrMsg() &#123;</span><br><span class="line">        return strMsg;</span><br><span class="line">    &#125;</span><br><span class="line">     @Override</span><br><span class="line">    public String getReason() &#123;</span><br><span class="line">        return reason;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><h4 id="异常伪代码"><a href="#异常伪代码" class="headerlink" title="异常伪代码"></a>异常伪代码</h4></li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class DataSimbaRuntimeException extends RuntimeException &#123;</span><br><span class="line">   </span><br><span class="line">    private String reason;</span><br><span class="line"></span><br><span class="line">    public DataSimbaRuntimeException(String msg) &#123;</span><br><span class="line">        this(msg, &quot;&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public DataSimbaRuntimeException(String msg, Throwable cause) &#123;</span><br><span class="line">        this(msg, &quot;&quot;, cause);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public DataSimbaRuntimeException(String msg, String reason) &#123;</span><br><span class="line">        super(msg);</span><br><span class="line">        this.reason &#x3D; reason;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public DataSimbaRuntimeException(String msg, String reason, Throwable cause) &#123;</span><br><span class="line">        super(msg, cause);</span><br><span class="line">        this.reason &#x3D; reason;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public String getReason() &#123;</span><br><span class="line">        return this.reason &#x3D;&#x3D; null ? &quot;&quot; : this.reason;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;***</span><br><span class="line"> * 请求校验异常</span><br><span class="line"> *&#x2F;</span><br><span class="line">public class RequestValidateException extends DataSimbaRuntimeException &#123;</span><br><span class="line"></span><br><span class="line">   public RequestValidateException(String msg, Throwable cause) &#123;</span><br><span class="line">        super(msg, cause);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public RequestValidateException(String msg) &#123;</span><br><span class="line">        super(msg);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public RequestValidateException(String msg, String reason) &#123;</span><br><span class="line">        super(msg, reason);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public RequestValidateException(String msg, String reason, Throwable cause) &#123;</span><br><span class="line">        super(msg, reason, cause);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;***</span><br><span class="line"> * 没有权限异常</span><br><span class="line"> *&#x2F;</span><br><span class="line">public class UnAuthorizedException extends DataSimbaRuntimeException &#123;</span><br><span class="line"></span><br><span class="line">   public UnAuthorizedException(String msg, Throwable cause) &#123;</span><br><span class="line">        super(msg, cause);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public UnAuthorizedException(String msg) &#123;</span><br><span class="line">        super(msg);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public UnAuthorizedException(String msg, String reason) &#123;</span><br><span class="line">        super(msg, reason);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public UnAuthorizedException(String msg, String reason, Throwable cause) &#123;</span><br><span class="line">        super(msg, reason, cause);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><h4 id="如何应用和error-code-约定"><a href="#如何应用和error-code-约定" class="headerlink" title="如何应用和error_code 约定"></a>如何应用和error_code 约定</h4><ol>
<li>比如 请求参数不对,需要抛出请求参数异常则<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">throw new RequestValidateException(&quot;lack of user id&quot;,&quot;lack of user id&quot;)</span><br></pre></td></tr></table></figure></li>
<li>在服务端创建异常拦截器,对异常统一处理</li>
<li>对于未知异常,http状态码是500, 已知异常和自定义异常http状态码为200</li>
<li>前置异常 error_code :400～499</li>
<li>外部异常 error_code :600～699</li>
<li>自定义异常 不同的自定义error_code长度从都从1000开始,如果业务需要可以跳号到2000或者到3000开始等等<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3>&nbsp;&nbsp;&nbsp;&nbsp;本次整理服务端异常和错误码的规范结合了之前工作的经验,回想了开发以来出现的异常场景,之前工作中虽然熟知如何合理的抛出异常,但是大前提是一个团队需要对异常作出响应的规范，如果没有规范每个人都抛出自己方式的异常，对于前端展示和问题排查都是非常不友好的，并且不够灵活，比如目前工作中遇到的国际化问题，必须服务端的异常非常准确,后面做国际化才能非常简单。</li>
</ol>
</li>
</ul>
]]></content>
      <categories>
        <category>项目规范</category>
      </categories>
      <tags>
        <tag>项目规范</tag>
        <tag>错误码</tag>
      </tags>
  </entry>
  <entry>
    <title>集合类框架 hashmap 源码详解</title>
    <url>/2020/09/22/%20java%E3%80%90%E9%9B%86%E5%90%88%E7%B1%BB%E6%A1%86%E6%9E%B6%E3%80%91%20hashmap%20%E6%BA%90%E7%A0%81%E8%AF%A6%E8%A7%A3/</url>
    <content><![CDATA[<h3 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h3><p>HashMap 可能是面试的时候必问的题目了，面试官为什么都偏爱拿这个问应聘者？因为 HashMap 它的设计结构和原理比较有意思，它既可以考初学者对 Java 集合的了解又可以深度的发现应聘者的数据结构功底。</p>
<span id="more"></span>
<h3 id="Java-7-中-HashMap"><a href="#Java-7-中-HashMap" class="headerlink" title="Java 7 中 HashMap"></a>Java 7 中 HashMap</h3><p>HashMap 是最简单的，一来我们非常熟悉，二来就是它不支持并发操作，所以源码也非常简单。d</p>
<p>首先，我们用下面这张图来介绍 HashMap 的结构。</p>
<p><img src="https://dmr-blog.oss-cn-shanghai.aliyuncs.com/blog/image_1586585802287.png" alt="image.png"></p>
<p>大方向上，HashMap 里面是一个数组，然后数组中每个元素是一个单向链表。为什么是这种的结构，这涉及到数据结构方面的知识了。</p>
<h3 id="HashMap的数据结构"><a href="#HashMap的数据结构" class="headerlink" title="HashMap的数据结构"></a>HashMap的数据结构</h3><p>数据结构中有数组和链表来实现对数据的存储，但这两者基本上是两个极端。</p>
<ul>
<li><p>数组<br>数组存储区间是连续的，占用内存严重，故空间复杂的很大。但数组的二分查找时间复杂度小，为O(1)；<br>数组的特点是：寻址容易，插入和删除困难；</p>
</li>
<li><p>链表<br>链表存储区间离散，占用内存比较宽松，故空间复杂度很小，但时间复杂度很大，为O(N)。<br>链表的特点是：寻址困难，插入和删除容易。</p>
</li>
<li><p>哈希表<br>那么我们能不能综合两者的特性，做出一种寻址容易，插入删除也容易的数据结构？答案是肯定的，这就是我们要提起的哈希表。哈希表（(Hash table）既满足了数据的查找方便，同时不占用太多的内容空间，使用也十分方便。</p>
</li>
</ul>
<p>哈希表有多种不同的实现方法，我接下来解释的是最常用的一种方法—— 拉链法，我们可以理解为“链表的数组”，如图：<br><img src="https://dmr-blog.oss-cn-shanghai.aliyuncs.com/blog/image_1586585882830.png" alt="image.png"></p>
<p>从上图我们可以发现哈希表是由数组+链表组成的，一个长度为16的数组中，每个数组中元素存储的是一个链表的头结点。</p>
<p>那么这些元素是按照什么样的规则存储到数组中呢。一般情况我们首先想到的就是元素的 key 的哈希值对数组长度取模得到 ( hash(key)%(length -1) )，这样一来，元素的分布相对来说是比较均匀的。但是，“模”运算的消耗还是比较大的，能不能找一种更快速，消耗更小的方式那？java中是这样做的：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">static int indexFor(int h, int length) &#123;  </span><br><span class="line">   return h &amp; (length-1);  </span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure>

<p>我们知道每个数据对象的hash对应唯一一个值，但是一个hash值不一定对应唯一的数据对象。如果两个不同对象的 hashCode 相同，此情况即称为哈希冲突。<br>比如上述HashMap中，12%16=12，28%16=12，108%16=12，140%16=12。所以12、28、108以及140都存储在数组下标为12的位置，然后依次放在数组中该位置的链表上。</p>
<p>注意：<br>对于那些 hash 冲突的数据，最新(最后) Put 的值放在链表的头部，为什么这样做呢？因为我们程序设计中认为最新放进去的值它的使用率会更高些，放在链表头比较容易查询获取到。</p>
<p>HashMap 里面实现一个静态内部类 Entry，Entry 包含四个属性：key，value，hash值和用于单向链表的 next。从属性key，value我们就能很明显的看出来 Entry 就是 HashMap 键值对实现的一个基础 bean，我们上面说到 HashMap的基础就是一个线性数组，这个数组就是 Entry[]，Map 里面的内容都保存在 Entry[] 里面。上图中，每个绿色的实体是嵌套类 Entry 的实例。</p>
<p>capacity：当前数组容量，始终保持 2^n，可以扩容，扩容后数组大小为当前的 2 倍。<br>loadFactor：负载因子，默认为0.75。<br>threshold：扩容的阈值，等于 capacity * loadFactor。<br>注意问题：</p>
<h4 id="1、扩容的数组的长度为什么保持-2-n？"><a href="#1、扩容的数组的长度为什么保持-2-n？" class="headerlink" title="1、扩容的数组的长度为什么保持 2^n？"></a>1、扩容的数组的长度为什么保持 2^n？</h4><p>其实这是为了保证通过hash方式获取下标的时候分布均匀。数组长度为2的n次幂的时候，不同的key 算得得 index 相同的几率较小，那么数据在数组上分布就比较均匀，也就是说碰撞的几率小，相对的，查询的时候就不用遍历某个位置上的链表，这样查询效率也就较高了。</p>
<h4 id="2、为什么负载因子的值默认为-0-75？"><a href="#2、为什么负载因子的值默认为-0-75？" class="headerlink" title="2、为什么负载因子的值默认为 0.75？"></a>2、为什么负载因子的值默认为 0.75？</h4><p>加载因子是表示Hash表中元素的填满的程度。</p>
<p>加载因子越大，填满的元素越多，空间利用率越高，但冲突的机会加大了。<br>反之,加载因子越小，填满的元素越少，冲突的机会减小，但空间浪费多了。<br>冲突的机会越大，则查找的成本越高。反之，查找的成本越小。</p>
<p>因此,必须在 “冲突的机会”与”空间利用率”之间寻找一种平衡与折衷。</p>
<h3 id="put-过程分析"><a href="#put-过程分析" class="headerlink" title="put 过程分析"></a>put 过程分析</h3><p>还是比较简单的，跟着代码走一遍吧。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public V put(K key, V value) &#123;</span><br><span class="line">    &#x2F;&#x2F; 当插入第一个元素的时候，需要先初始化数组大小</span><br><span class="line">    if (table &#x3D;&#x3D; EMPTY_TABLE) &#123;</span><br><span class="line">        inflateTable(threshold);</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F; 如果 key 为 null，感兴趣的可以往里看，最终会将这个 entry 放到 table[0] 中</span><br><span class="line">    if (key &#x3D;&#x3D; null)</span><br><span class="line">        return putForNullKey(value);</span><br><span class="line">    &#x2F;&#x2F; 1. 求 key 的 hash 值</span><br><span class="line">    int hash &#x3D; hash(key);</span><br><span class="line">    &#x2F;&#x2F; 2. 找到对应的数组下标</span><br><span class="line">    int i &#x3D; indexFor(hash, table.length);</span><br><span class="line">    &#x2F;&#x2F; 3. 遍历一下对应下标处的链表，看是否有重复的 key 已经存在，</span><br><span class="line">    &#x2F;&#x2F;    如果有，直接覆盖，put 方法返回旧值就结束了</span><br><span class="line">    for (Entry&lt;K,V&gt; e &#x3D; table[i]; e !&#x3D; null; e &#x3D; e.next) &#123;</span><br><span class="line">        Object k;</span><br><span class="line">        if (e.hash &#x3D;&#x3D; hash &amp;&amp; ((k &#x3D; e.key) &#x3D;&#x3D; key || key.equals(k))) &#123;</span><br><span class="line">            V oldValue &#x3D; e.value;</span><br><span class="line">            e.value &#x3D; value;</span><br><span class="line">            e.recordAccess(this);</span><br><span class="line">            return oldValue;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    modCount++;</span><br><span class="line">    &#x2F;&#x2F; 4. 不存在重复的 key，将此 entry 添加到链表中，细节后面说</span><br><span class="line">    addEntry(hash, key, value, i);</span><br><span class="line">    return null;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="数组初始化（inflateTable）"><a href="#数组初始化（inflateTable）" class="headerlink" title="数组初始化（inflateTable）"></a>数组初始化（inflateTable）</h4><p>在第一个元素插入 HashMap 的时候做一次数组的初始化，就是先确定初始的数组大小，并计算数组扩容的阈值。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">private void inflateTable(int toSize) &#123;</span><br><span class="line">    &#x2F;&#x2F; 保证数组大小一定是 2 的 n 次方。</span><br><span class="line">    &#x2F;&#x2F; 比如这样初始化：new HashMap(20)，那么处理成初始数组大小是 32</span><br><span class="line">    int capacity &#x3D; roundUpToPowerOf2(toSize);</span><br><span class="line">    &#x2F;&#x2F; 计算扩容阈值：capacity * loadFactor</span><br><span class="line">    threshold &#x3D; (int) Math.min(capacity * loadFactor, MAXIMUM_CAPACITY + 1);</span><br><span class="line">    &#x2F;&#x2F; 算是初始化数组吧</span><br><span class="line">    table &#x3D; new Entry[capacity];</span><br><span class="line">    initHashSeedAsNeeded(capacity); &#x2F;&#x2F;ignore</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里有一个将数组大小保持为 2 的 n 次方的做法，Java7 和 Java8 的 HashMap 和 ConcurrentHashMap 都有相应的要求，只不过实现的代码稍微有些不同，后面再看到的时候就知道了。</p>
<h3 id="计算具体数组位置（indexFor）"><a href="#计算具体数组位置（indexFor）" class="headerlink" title="计算具体数组位置（indexFor）"></a>计算具体数组位置（indexFor）</h3><p>这个简单，我们自己也能 YY 一个：使用 key 的 hash 值对数组长度进行取模就可以了。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">static int indexFor(int hash, int length) &#123;</span><br><span class="line">    &#x2F;&#x2F; assert Integer.bitCount(length) &#x3D;&#x3D; 1 : &quot;length must be a non-zero power of 2&quot;;</span><br><span class="line">    return hash &amp; (length-1);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个方法很简单，简单说就是取 hash 值的低 n 位。如在数组长度为 32 的时候，其实取的就是 key 的 hash 值的低 5 位，作为它在数组中的下标位置。</p>
<h3 id="添加节点到链表中（addEntry）"><a href="#添加节点到链表中（addEntry）" class="headerlink" title="添加节点到链表中（addEntry）"></a>添加节点到链表中（addEntry）</h3><p>找到数组下标后，会先进行 key 判重，如果没有重复，就准备将新值放入到链表的表头。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">void addEntry(int hash, K key, V value, int bucketIndex) &#123;</span><br><span class="line">    &#x2F;&#x2F; 如果当前 HashMap 大小已经达到了阈值，并且新值要插入的数组位置已经有元素了，那么要扩容</span><br><span class="line">    if ((size &gt;&#x3D; threshold) &amp;&amp; (null !&#x3D; table[bucketIndex])) &#123;</span><br><span class="line">        &#x2F;&#x2F; 扩容，后面会介绍一下</span><br><span class="line">        resize(2 * table.length);</span><br><span class="line">        &#x2F;&#x2F; 扩容以后，重新计算 hash 值</span><br><span class="line">        hash &#x3D; (null !&#x3D; key) ? hash(key) : 0;</span><br><span class="line">        &#x2F;&#x2F; 重新计算扩容后的新的下标</span><br><span class="line">        bucketIndex &#x3D; indexFor(hash, table.length);</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F; 往下看</span><br><span class="line">    createEntry(hash, key, value, bucketIndex);</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F; 这个很简单，其实就是将新值放到链表的表头，然后 size++</span><br><span class="line">void createEntry(int hash, K key, V value, int bucketIndex) &#123;</span><br><span class="line">    Entry&lt;K,V&gt; e &#x3D; table[bucketIndex];</span><br><span class="line">    table[bucketIndex] &#x3D; new Entry&lt;&gt;(hash, key, value, e);</span><br><span class="line">    size++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个方法的主要逻辑就是先判断是否需要扩容，需要的话先扩容，然后再将这个新的数据插入到扩容后的数组的相应位置处的链表的表头。</p>
<h3 id="数组扩容（resize）"><a href="#数组扩容（resize）" class="headerlink" title="数组扩容（resize）"></a>数组扩容（resize）</h3><p>前面我们看到，在插入新值的时候，如果当前的 size 已经达到了阈值，并且要插入的数组位置上已经有元素，那么就会触发扩容，扩容后，数组大小为原来的 2 倍。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">void resize(int newCapacity) &#123;</span><br><span class="line">    Entry[] oldTable &#x3D; table;</span><br><span class="line">    int oldCapacity &#x3D; oldTable.length;</span><br><span class="line">    if (oldCapacity &#x3D;&#x3D; MAXIMUM_CAPACITY) &#123;</span><br><span class="line">        threshold &#x3D; Integer.MAX_VALUE;</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F; 新的数组</span><br><span class="line">    Entry[] newTable &#x3D; new Entry[newCapacity];</span><br><span class="line">    &#x2F;&#x2F; 将原来数组中的值迁移到新的更大的数组中</span><br><span class="line">    transfer(newTable, initHashSeedAsNeeded(newCapacity));</span><br><span class="line">    table &#x3D; newTable;</span><br><span class="line">    threshold &#x3D; (int)Math.min(newCapacity * loadFactor, MAXIMUM_CAPACITY + 1);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>扩容就是用一个新的大数组替换原来的小数组，并将原来数组中的值迁移到新的数组中。</p>
<p>由于是双倍扩容，迁移过程中，会将原来 table[i] 中的链表的所有节点，分拆到新的数组的 newTable[i]和 newTable[i + oldLength] 位置上。如原来数组长度是 16，那么扩容后，原来 table[0] 处的链表中的所有元素会被分配到新数组中 newTable[0] 和 newTable[16] 这两个位置。代码比较简单，这里就不展开了。</p>
<h3 id="get-过程分析"><a href="#get-过程分析" class="headerlink" title="get 过程分析"></a>get 过程分析</h3><p>相对于 put 过程，get 过程是非常简单的。</p>
<p>根据 key 计算 hash 值。<br>找到相应的数组下标：hash &amp; (length - 1)。<br>遍历该数组位置处的链表，直到找到相等(==或equals)的 key。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public V get(Object key) &#123;</span><br><span class="line">    &#x2F;&#x2F; 之前说过，key 为 null 的话，会被放到 table[0]，所以只要遍历下 table[0] 处的链表就可以了</span><br><span class="line">    if (key &#x3D;&#x3D; null)</span><br><span class="line">        return getForNullKey();</span><br><span class="line">    &#x2F;&#x2F; </span><br><span class="line">    Entry&lt;K,V&gt; entry &#x3D; getEntry(key);</span><br><span class="line"></span><br><span class="line">    return null &#x3D;&#x3D; entry ? null : entry.getValue();</span><br><span class="line">&#125;</span><br><span class="line">getEntry(key):</span><br><span class="line">final Entry&lt;K,V&gt; getEntry(Object key) &#123;</span><br><span class="line">    if (size &#x3D;&#x3D; 0) &#123;</span><br><span class="line">        return null;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    int hash &#x3D; (key &#x3D;&#x3D; null) ? 0 : hash(key);</span><br><span class="line">    &#x2F;&#x2F; 确定数组下标，然后从头开始遍历链表，直到找到为止</span><br><span class="line">    for (Entry&lt;K,V&gt; e &#x3D; table[indexFor(hash, table.length)];</span><br><span class="line">         e !&#x3D; null;</span><br><span class="line">         e &#x3D; e.next) &#123;</span><br><span class="line">        Object k;</span><br><span class="line">        if (e.hash &#x3D;&#x3D; hash &amp;&amp;</span><br><span class="line">            ((k &#x3D; e.key) &#x3D;&#x3D; key || (key !&#x3D; null &amp;&amp; key.equals(k))))</span><br><span class="line">            return e;</span><br><span class="line">    &#125;</span><br><span class="line">     return null;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Java8-中-HashMap"><a href="#Java8-中-HashMap" class="headerlink" title="Java8 中 HashMap"></a>Java8 中 HashMap</h3><p>Java8 对 HashMap 进行了一些修改，最大的不同就是利用了红黑树，所以其由 数组+链表+红黑树 组成。</p>
<p>根据 Java7 HashMap 的介绍，我们知道，查找的时候，根据 hash 值我们能够快速定位到数组的具体下标，但是之后的话，需要顺着链表一个个比较下去才能找到我们需要的，时间复杂度取决于链表的长度，为 O(n)。</p>
<p>为了降低这部分的开销，在 Java8 中，当链表中的元素达到了 8 个时，会将链表转换为红黑树，在这些位置进行查找的时候可以降低时间复杂度为 O(logN)。</p>
<p>来一张图简单示意一下吧：<br><img src="https://dmr-blog.oss-cn-shanghai.aliyuncs.com/blog/image_1586586239096.png" alt="image.png"></p>
<p>注意，上图是示意图，主要是描述结构，不会达到这个状态的，因为这么多数据的时候早就扩容了。</p>
<p>下面，我们还是用代码来介绍吧，个人感觉，Java8 的源码可读性要差一些，不过精简一些。</p>
<p>Java7 中使用 Entry 来代表每个 HashMap 中的数据节点，Java8 中使用 Node，基本没有区别，都是 key，value，hash 和 next 这四个属性，不过，Node 只能用于链表的情况，红黑树的情况需要使用 TreeNode。</p>
<p>我们根据数组元素中，第一个节点数据类型是 Node 还是 TreeNode 来判断该位置下是链表还是红黑树的。</p>
<h3 id="put-过程分析-1"><a href="#put-过程分析-1" class="headerlink" title="put 过程分析"></a>put 过程分析</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public V put(K key, V value) &#123;</span><br><span class="line">    return putVal(hash(key), key, value, false, true);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>// 第三个参数 onlyIfAbsent 如果是 true，那么只有在不存在该 key 时才会进行 put 操作<br>// 第四个参数 evict 我们这里不关心</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">final V putVal(int hash, K key, V value, boolean onlyIfAbsent,</span><br><span class="line">               boolean evict) &#123;</span><br><span class="line">    Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; int n, i;</span><br><span class="line">    &#x2F;&#x2F; 第一次 put 值的时候，会触发下面的 resize()，类似 java7 的第一次 put 也要初始化数组长度</span><br><span class="line">    &#x2F;&#x2F; 第一次 resize 和后续的扩容有些不一样，因为这次是数组从 null 初始化到默认的 16 或自定义的初始容量</span><br><span class="line">    if ((tab &#x3D; table) &#x3D;&#x3D; null || (n &#x3D; tab.length) &#x3D;&#x3D; 0)</span><br><span class="line">        n &#x3D; (tab &#x3D; resize()).length;</span><br><span class="line">    &#x2F;&#x2F; 找到具体的数组下标，如果此位置没有值，那么直接初始化一下 Node 并放置在这个位置就可以了</span><br><span class="line">    if ((p &#x3D; tab[i &#x3D; (n - 1) &amp; hash]) &#x3D;&#x3D; null)</span><br><span class="line">        tab[i] &#x3D; newNode(hash, key, value, null);</span><br><span class="line"></span><br><span class="line">    else &#123;&#x2F;&#x2F; 数组该位置有数据</span><br><span class="line">        Node&lt;K,V&gt; e; K k;</span><br><span class="line">        &#x2F;&#x2F; 首先，判断该位置的第一个数据和我们要插入的数据，key 是不是&quot;相等&quot;，如果是，取出这个节点</span><br><span class="line">        if (p.hash &#x3D;&#x3D; hash &amp;&amp;</span><br><span class="line">            ((k &#x3D; p.key) &#x3D;&#x3D; key || (key !&#x3D; null &amp;&amp; key.equals(k))))</span><br><span class="line">            e &#x3D; p;</span><br><span class="line">        &#x2F;&#x2F; 如果该节点是代表红黑树的节点，调用红黑树的插值方法，本文不展开说红黑树</span><br><span class="line">        else if (p instanceof TreeNode)</span><br><span class="line">            e &#x3D; ((TreeNode&lt;K,V&gt;)p).putTreeVal(this, tab, hash, key, value);</span><br><span class="line">        else &#123;</span><br><span class="line">            &#x2F;&#x2F; 到这里，说明数组该位置上是一个链表</span><br><span class="line">            for (int binCount &#x3D; 0; ; ++binCount) &#123;</span><br><span class="line">                &#x2F;&#x2F; 插入到链表的最后面(Java7 是插入到链表的最前面)</span><br><span class="line">                if ((e &#x3D; p.next) &#x3D;&#x3D; null) &#123;</span><br><span class="line">                    p.next &#x3D; newNode(hash, key, value, null);</span><br><span class="line">                    &#x2F;&#x2F; TREEIFY_THRESHOLD 为 8，所以，如果新插入的值是链表中的第 8 个</span><br><span class="line">                    &#x2F;&#x2F; 会触发下面的 treeifyBin，也就是将链表转换为红黑树</span><br><span class="line">                    if (binCount &gt;&#x3D; TREEIFY_THRESHOLD - 1) &#x2F;&#x2F; -1 for 1st</span><br><span class="line">                        treeifyBin(tab, hash);</span><br><span class="line">                    break;</span><br><span class="line">                &#125;</span><br><span class="line">                &#x2F;&#x2F; 如果在该链表中找到了&quot;相等&quot;的 key(&#x3D;&#x3D; 或 equals)</span><br><span class="line">                if (e.hash &#x3D;&#x3D; hash &amp;&amp;</span><br><span class="line">                    ((k &#x3D; e.key) &#x3D;&#x3D; key || (key !&#x3D; null &amp;&amp; key.equals(k))))</span><br><span class="line">                    &#x2F;&#x2F; 此时 break，那么 e 为链表中[与要插入的新值的 key &quot;相等&quot;]的 node</span><br><span class="line">                    break;</span><br><span class="line">                p &#x3D; e;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        &#x2F;&#x2F; e!&#x3D;null 说明存在旧值的key与要插入的key&quot;相等&quot;</span><br><span class="line">        &#x2F;&#x2F; 对于我们分析的put操作，下面这个 if 其实就是进行 &quot;值覆盖&quot;，然后返回旧值</span><br><span class="line">        if (e !&#x3D; null) &#123;</span><br><span class="line">            V oldValue &#x3D; e.value;</span><br><span class="line">            if (!onlyIfAbsent || oldValue &#x3D;&#x3D; null)</span><br><span class="line">                e.value &#x3D; value;</span><br><span class="line">            afterNodeAccess(e);</span><br><span class="line">            return oldValue;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ++modCount;</span><br><span class="line">    &#x2F;&#x2F; 如果 HashMap 由于新插入这个值导致 size 已经超过了阈值，需要进行扩容</span><br><span class="line">    if (++size &gt; threshold)</span><br><span class="line">        resize();</span><br><span class="line">    afterNodeInsertion(evict);</span><br><span class="line">    return null;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>和 Java7 稍微有点不一样的地方就是，Java7 是先扩容后插入新值的，Java8 先插值再扩容，不过这个不重要。</p>
<h3 id="数组扩容"><a href="#数组扩容" class="headerlink" title="数组扩容"></a>数组扩容</h3><p>resize() 方法用于初始化数组或数组扩容，每次扩容后，容量为原来的 2 倍，并进行数据迁移。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">final Node&lt;K,V&gt;[] resize() &#123;</span><br><span class="line">    Node&lt;K,V&gt;[] oldTab &#x3D; table;</span><br><span class="line">    int oldCap &#x3D; (oldTab &#x3D;&#x3D; null) ? 0 : oldTab.length;</span><br><span class="line">    int oldThr &#x3D; threshold;</span><br><span class="line">    int newCap, newThr &#x3D; 0;</span><br><span class="line">    if (oldCap &gt; 0) &#123; &#x2F;&#x2F; 对应数组扩容</span><br><span class="line">        if (oldCap &gt;&#x3D; MAXIMUM_CAPACITY) &#123;</span><br><span class="line">            threshold &#x3D; Integer.MAX_VALUE;</span><br><span class="line">            return oldTab;</span><br><span class="line">        &#125;</span><br><span class="line">        &#x2F;&#x2F; 将数组大小扩大一倍</span><br><span class="line">        else if ((newCap &#x3D; oldCap &lt;&lt; 1) &lt; MAXIMUM_CAPACITY &amp;&amp;</span><br><span class="line">                 oldCap &gt;&#x3D; DEFAULT_INITIAL_CAPACITY)</span><br><span class="line">            &#x2F;&#x2F; 将阈值扩大一倍</span><br><span class="line">            newThr &#x3D; oldThr &lt;&lt; 1; &#x2F;&#x2F; double threshold</span><br><span class="line">    &#125;</span><br><span class="line">    else if (oldThr &gt; 0) &#x2F;&#x2F; 对应使用 new HashMap(int initialCapacity) 初始化后，第一次 put 的时候</span><br><span class="line">        newCap &#x3D; oldThr;</span><br><span class="line">    else &#123;&#x2F;&#x2F; 对应使用 new HashMap() 初始化后，第一次 put 的时候</span><br><span class="line">        newCap &#x3D; DEFAULT_INITIAL_CAPACITY;</span><br><span class="line">        newThr &#x3D; (int)(DEFAULT_LOAD_FACTOR * DEFAULT_INITIAL_CAPACITY);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if (newThr &#x3D;&#x3D; 0) &#123;</span><br><span class="line">        float ft &#x3D; (float)newCap * loadFactor;</span><br><span class="line">        newThr &#x3D; (newCap &lt; MAXIMUM_CAPACITY &amp;&amp; ft &lt; (float)MAXIMUM_CAPACITY ?</span><br><span class="line">                  (int)ft : Integer.MAX_VALUE);</span><br><span class="line">    &#125;</span><br><span class="line">    threshold &#x3D; newThr;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 用新的数组大小初始化新的数组</span><br><span class="line">    Node&lt;K,V&gt;[] newTab &#x3D; (Node&lt;K,V&gt;[])new Node[newCap];</span><br><span class="line">    table &#x3D; newTab; &#x2F;&#x2F; 如果是初始化数组，到这里就结束了，返回 newTab 即可</span><br><span class="line"></span><br><span class="line">    if (oldTab !&#x3D; null) &#123;</span><br><span class="line">        &#x2F;&#x2F; 开始遍历原数组，进行数据迁移。</span><br><span class="line">        for (int j &#x3D; 0; j &lt; oldCap; ++j) &#123;</span><br><span class="line">            Node&lt;K,V&gt; e;</span><br><span class="line">            if ((e &#x3D; oldTab[j]) !&#x3D; null) &#123;</span><br><span class="line">                oldTab[j] &#x3D; null;</span><br><span class="line">                &#x2F;&#x2F; 如果该数组位置上只有单个元素，那就简单了，简单迁移这个元素就可以了</span><br><span class="line">                if (e.next &#x3D;&#x3D; null)</span><br><span class="line">                    newTab[e.hash &amp; (newCap - 1)] &#x3D; e;</span><br><span class="line">                &#x2F;&#x2F; 如果是红黑树，具体我们就不展开了</span><br><span class="line">                else if (e instanceof TreeNode)</span><br><span class="line">                    ((TreeNode&lt;K,V&gt;)e).split(this, newTab, j, oldCap);</span><br><span class="line">                else &#123; </span><br><span class="line">                    &#x2F;&#x2F; 这块是处理链表的情况，</span><br><span class="line">                    &#x2F;&#x2F; 需要将此链表拆成两个链表，放到新的数组中，并且保留原来的先后顺序</span><br><span class="line">                    &#x2F;&#x2F; loHead、loTail 对应一条链表，hiHead、hiTail 对应另一条链表，代码还是比较简单的</span><br><span class="line">                    Node&lt;K,V&gt; loHead &#x3D; null, loTail &#x3D; null;</span><br><span class="line">                    Node&lt;K,V&gt; hiHead &#x3D; null, hiTail &#x3D; null;</span><br><span class="line">                    Node&lt;K,V&gt; next;</span><br><span class="line">                    do &#123;</span><br><span class="line">                        next &#x3D; e.next;</span><br><span class="line">                        if ((e.hash &amp; oldCap) &#x3D;&#x3D; 0) &#123;</span><br><span class="line">                            if (loTail &#x3D;&#x3D; null)</span><br><span class="line">                                loHead &#x3D; e;</span><br><span class="line">                            else</span><br><span class="line">                                loTail.next &#x3D; e;</span><br><span class="line">                            loTail &#x3D; e;</span><br><span class="line">                        &#125;</span><br><span class="line">                        else &#123;</span><br><span class="line">                            if (hiTail &#x3D;&#x3D; null)</span><br><span class="line">                                hiHead &#x3D; e;</span><br><span class="line">                            else</span><br><span class="line">                                hiTail.next &#x3D; e;</span><br><span class="line">                            hiTail &#x3D; e;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125; while ((e &#x3D; next) !&#x3D; null);</span><br><span class="line">                    if (loTail !&#x3D; null) &#123;</span><br><span class="line">                        loTail.next &#x3D; null;</span><br><span class="line">                        &#x2F;&#x2F; 第一条链表</span><br><span class="line">                        newTab[j] &#x3D; loHead;</span><br><span class="line">                    &#125;</span><br><span class="line">                    if (hiTail !&#x3D; null) &#123;</span><br><span class="line">                        hiTail.next &#x3D; null;</span><br><span class="line">                        &#x2F;&#x2F; 第二条链表的新的位置是 j + oldCap，这个很好理解</span><br><span class="line">                        newTab[j + oldCap] &#x3D; hiHead;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return newTab;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="get-过程分析-1"><a href="#get-过程分析-1" class="headerlink" title="get 过程分析"></a>get 过程分析</h3><p>相对于 put 来说，get 真的太简单了。</p>
<p>计算 key 的 hash 值，根据 hash 值找到对应数组下标: hash &amp; (length-1).<br>判断数组该位置处的元素是否刚好就是我们要找的，如果不是，走第三步.<br>判断该元素类型是否是 TreeNode，如果是，用红黑树的方法取数据，如果不是，走第四步.<br>遍历链表，直到找到相等(==或equals)的 key.</p>
<pre><code>public V get(Object key) &#123;
    Node&lt;K,V&gt; e;
    return (e = getNode(hash(key), key)) == null ? null : e.value;
&#125;
final Node&lt;K,V&gt; getNode(int hash, Object key) &#123;
    Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; first, e; int n; K k;
    if ((tab = table) != null &amp;&amp; (n = tab.length) &gt; 0 &amp;&amp;
        (first = tab[(n - 1) &amp; hash]) != null) &#123;
        // 判断第一个节点是不是就是需要的
        if (first.hash == hash &amp;&amp; // always check first node
            ((k = first.key) == key || (key != null &amp;&amp; key.equals(k))))
            return first;
        if ((e = first.next) != null) &#123;
            // 判断是否是红黑树
            if (first instanceof TreeNode)
                return ((TreeNode&lt;K,V&gt;)first).getTreeNode(hash, key);

            // 链表遍历
            do &#123;
                if (e.hash == hash &amp;&amp;
                    ((k = e.key) == key || (key != null &amp;&amp; key.equals(k))))
                    return e;
            &#125; while ((e = e.next) != null);
        &#125;
    &#125;
    return null;
&#125;
</code></pre>
]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>java基础</tag>
        <tag>源码</tag>
        <tag>hashmap</tag>
      </tags>
  </entry>
  <entry>
    <title>设计模式 行为型模式 观察者模式</title>
    <url>/2020/09/14/%E3%80%90%E8%A1%8C%E4%B8%BA%E5%9E%8B%E6%A8%A1%E5%BC%8F%E3%80%91%20%E8%A7%82%E5%AF%9F%E8%80%85%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<h3 id="描述"><a href="#描述" class="headerlink" title="描述"></a>描述</h3><p>观察者模式又叫发布订阅模式,拥有一个监听者,如果一个被监听者发生了改变则会通知到所有监听者。例子,警察和嫌疑犯之间就是观察者模式。微信朋友圈,相对于好友,你就是观察者,微信好友发送朋友圈你会收到通知</p>
<span id="more"></span>
<h3 id="类图"><a href="#类图" class="headerlink" title="类图"></a>类图</h3><p><img src="https://dmr-blog.oss-cn-shanghai.aliyuncs.com/blog/image_1586165515592.png" alt="image.png"></p>
<h3 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class PoliceMan &#123;</span><br><span class="line">    private String name;</span><br><span class="line"></span><br><span class="line">    public PoliceMan(String name) &#123;</span><br><span class="line">        this.name &#x3D; name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void name() &#123;</span><br><span class="line">        System.out.println(&quot;我是:&quot; + name + &quot;收到消息&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class XianFan1 &#123;</span><br><span class="line">    private String name;</span><br><span class="line"></span><br><span class="line">    public XianFan1(String name) &#123;</span><br><span class="line">        this.name &#x3D; name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private List&lt;PoliceMan&gt; policeManList &#x3D; new ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    public void addPolice(PoliceMan policeMan) &#123;</span><br><span class="line">        if (!policeManList.contains(policeMan)) &#123;</span><br><span class="line">            policeManList.add(policeMan);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void run() &#123;</span><br><span class="line">        System.out.println(name + &quot;跑了&quot;);</span><br><span class="line">        notifyAllPoliceMan();</span><br><span class="line">    &#125;</span><br><span class="line">    public void notifyAllPoliceMan()&#123;</span><br><span class="line">        policeManList.stream().forEach(i -&gt; i.name());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>测试类</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class Main &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        PoliceMan policeManA &#x3D;new PoliceMan(&quot;警察:A&quot;);</span><br><span class="line">        PoliceMan policeManB &#x3D;new PoliceMan(&quot;警察:B&quot;);</span><br><span class="line">        PoliceMan policeManC &#x3D;new PoliceMan(&quot;警察:C&quot;);</span><br><span class="line">        XianFan1 xianFan1 &#x3D;new XianFan1(&quot;嫌犯1&quot;);</span><br><span class="line">        xianFan1.addPolice(policeManA);</span><br><span class="line">        xianFan1.addPolice(policeManB);</span><br><span class="line">        xianFan1.addPolice(policeManC);</span><br><span class="line">        xianFan1.run();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><img src="https://dmr-blog.oss-cn-shanghai.aliyuncs.com/blog/image_1586166152531.png" alt="image.png"></p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>可以看到在被观察者类上面存放观察者的集合,在调用观察者的相关方法的时候循环调用观察者,从而实现发布订阅模式。<br>被观察者需要提供添加观察者和通知观察者方法</p>
<ul>
<li>观察者和被观察者的实现复合开闭原则</li>
<li>实现通知模式</li>
<li>如果观察者过多通知的时间成本加大</li>
<li>观察者只知道目标变化,但是具体变化情况不得而知。可以定义相关事件来区分</li>
</ul>
]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title>设计模式 结构型模式 桥接模式</title>
    <url>/2020/08/29/%E3%80%90%E7%BB%93%E6%9E%84%E5%9E%8B%E6%A8%A1%E5%BC%8F%E3%80%91%20%E6%A1%A5%E6%8E%A5%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<h3 id="描述"><a href="#描述" class="headerlink" title="描述"></a>描述</h3><p> 桥接（Bridge）是用于把抽象化与实现化解耦，使得二者可以独立变化。这种类型的设计模式属于结构型模式，它通过提供抽象化和实现化之间的桥接结构，来实现二者的解耦。</p>
<span id="more"></span>
<p>　　这种模式涉及到一个作为桥接的接口，使得实体类的功能独立于接口实现类。这两种类型的类可被结构化改变而互不影响。<br>例子：总共又长方形、正方形、三角形、圆形四个形状。如果现在有需求每个形状要有红、黄、蓝，三个颜色。最能想到的是在每个形状下在创建长方形-红、长方形-黄、长方形-蓝、正方形-红、正方形-黄、正方形-蓝…..等等来进行实现。<br>而使用桥接模式则创建一个抽象的 颜色类。并且实现红色类,黄色类,蓝色类。<br>扩充的形状类存储颜色的引用对象在创建形状的时候去添加对应的颜色引用对象。</p>
<h3 id="类图"><a href="#类图" class="headerlink" title="类图"></a>类图</h3><p><img src="https://dmr-blog.oss-cn-shanghai.aliyuncs.com/blog/image_1586163074010.png" alt="image.png"> </p>
<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public interface Colour &#123;</span><br><span class="line">    void desc();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class Blue implements Colour &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void desc() &#123;</span><br><span class="line">        System.out.println(&quot;蓝色&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">public class Red implements Colour &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void desc() &#123;</span><br><span class="line">        System.out.println(&quot;红色&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">public class Yellow implements Colour</span><br><span class="line">&#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void desc() &#123;</span><br><span class="line">        System.out.println(&quot;黄色&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">public abstract class Graphical &#123;</span><br><span class="line">    private Colour colour;</span><br><span class="line"></span><br><span class="line">    public Graphical(Colour colour) &#123;</span><br><span class="line">        this.colour &#x3D; colour;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    abstract void desc();</span><br><span class="line">    public Colour getColour()&#123;</span><br><span class="line">        return colour;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class Rectangle extends Graphical &#123;</span><br><span class="line"></span><br><span class="line">    public Rectangle(Colour colour)&#123;</span><br><span class="line">      super(colour);</span><br><span class="line">    &#125;</span><br><span class="line">    @Override</span><br><span class="line">    public void desc() &#123;</span><br><span class="line">        System.out.println(&quot;长方形&quot;);</span><br><span class="line">        getColour().desc();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class Square extends Graphical &#123;</span><br><span class="line"></span><br><span class="line">    public Square(Colour colour)&#123;</span><br><span class="line">      super(colour);</span><br><span class="line">    &#125;</span><br><span class="line">    @Override</span><br><span class="line">    public void desc() &#123;</span><br><span class="line">        System.out.println(&quot;正方形&quot;);</span><br><span class="line">        getColour().desc();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class Triangle extends Graphical &#123;</span><br><span class="line"></span><br><span class="line">    public Triangle(Colour colour) &#123;</span><br><span class="line">        super(colour);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void desc() &#123;</span><br><span class="line">        System.out.println(&quot;三角形&quot;);</span><br><span class="line">        getColour().desc();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">public class Main &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        Rectangle rectangle &#x3D; new Rectangle(new Blue());</span><br><span class="line">        rectangle.desc();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><img src="https://dmr-blog.oss-cn-shanghai.aliyuncs.com/blog/image_1586164465035.png" alt="image.png"></p>
<h3 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h3><ol>
<li>解耦解耦解耦解耦解耦解耦解耦</li>
<li>实现细节对客户透明，可以对用户隐藏实现细节<h3 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h3>桥接模式的引入会增加系统的理解与设计难度，由于聚合关联关系建立在抽象层，要求开发者针对抽象进</li>
</ol>
]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title>设计模式 结构型模式 外观模式</title>
    <url>/2020/08/19/%E3%80%90%E7%BB%93%E6%9E%84%E5%9E%8B%E6%A8%A1%E5%BC%8F%E3%80%91%20%E5%A4%96%E8%A7%82%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<h3 id="描述"><a href="#描述" class="headerlink" title="描述"></a>描述</h3><p>外观模式属于结构型模式的一种,当子系统的方法众多,可以引用外观模式在外观类将子方法的方法封装起来,外观类提供简单的api方法。外观类的方法屏蔽掉了复杂的api调用</p>
<span id="more"></span>
<h3 id="类图"><a href="#类图" class="headerlink" title="类图"></a>类图</h3><p>下图为外观模式类图<br><img src="https://dmr-blog.oss-cn-shanghai.aliyuncs.com/blog/image_1586160133719.png" alt="image.png"></p>
<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class SubMethod1 &#123;</span><br><span class="line">    public void method1()&#123;</span><br><span class="line">        System.out.println(&quot;子系统中类1的方法1&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class SubMethod2 &#123;</span><br><span class="line">     public void method2()&#123;</span><br><span class="line">         System.out.println(&quot;子系统中类2方法2&quot;);</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class SubMethod3 &#123;</span><br><span class="line">    public void method3()&#123;</span><br><span class="line">        System.out.println(&quot;子系统类3方法3&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class Facader &#123;</span><br><span class="line">    private SubMethod1 sm1 &#x3D; new SubMethod1();</span><br><span class="line">    private SubMethod2 sm2 &#x3D; new SubMethod2();</span><br><span class="line">    private SubMethod3 sm3 &#x3D; new SubMethod3();</span><br><span class="line">    public void facMethod1()&#123;</span><br><span class="line">        sm1.method1();</span><br><span class="line">        sm2.method2();</span><br><span class="line">    &#125;</span><br><span class="line">    public void facMethod2()&#123;</span><br><span class="line">        sm2.method2();</span><br><span class="line">        sm3.method3();</span><br><span class="line">        sm1.method1();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class Clienter &#123;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        Facader face &#x3D; new Facader();</span><br><span class="line">        face.facMethod1();</span><br><span class="line">&#x2F;&#x2F;        face.facMethod2();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>优点<br>外观模式的优点<br>对客户屏蔽子系统组件，减少了客户处理的对象数目并使得子系统使用起来更加容易。通过引入外观模式，客户代码将变得很简单，与之关联的对象也很少。<br>实现了子系统与客户之间的松耦合关系，这使得子系统的组件变化不会影响到调用它的客户类，只需要调整外观类即可。<br>降低了大型软件系统中的编译依赖性，并简化了系统在不同平台之间的移植过程，因为编译一个子系统一般不需要编译所有其他的子系统。一个子系统的修改对其他子系统没有任何影响，而且子系统内部变化也不会影响到外观对象。<br>只是提供了一个访问子系统的统一入口，并不影响用户直接使用子系统类。</li>
<li>缺点<br>外观模式的缺点<br>不能很好地限制客户使用子系统类，如果对客户访问子系统类做太多的限制则减少了可变性和灵活性。<br>在不引入抽象外观类的情况下，增加新的子系统可能需要修改外观类或客户端的源代码，违背了“开闭原则”。</li>
</ul>
<p>自己总结<br>优点：</p>
<ol>
<li>功能调用子系统的方法太多,不好维护使用外观模式来屏蔽复杂子系统方法的调用,代码更简单</li>
<li>子类和使用者之间体现了松耦合的关系,修改功能只需要修改外观类即可<br>缺点:<br>如果使用太多子系统的方法,会使外观类不好维护,可变性灵活性下降</li>
</ol>
]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title>设计模式 结构型模式 适配器模式</title>
    <url>/2020/08/15/%E3%80%90%E7%BB%93%E6%9E%84%E5%9E%8B%E6%A8%A1%E5%BC%8F%E3%80%91%20%E9%80%82%E9%85%8D%E5%99%A8%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<h3 id="描述"><a href="#描述" class="headerlink" title="描述"></a>描述</h3><p>   适配器模式属于结构性模式,将适配类的api转化为目标类的api,如mac电脑使用的是typec的接口,连接显示器需要hdmi接口。我们要使用mac连接显示器,需要使用扩展坞,这其实就是适配器模式。</p>
<h3 id="类图"><a href="#类图" class="headerlink" title="类图"></a>类图</h3><p><img src="https://dmr-blog.oss-cn-shanghai.aliyuncs.com/blog/image_1586158261596.png" alt="image.png"></p>
<span id="more"></span>
<h3 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h3><ul>
<li>类适配<br>是基于继承实现的</li>
<li>对象适配<br>使用组合方式实现,更加灵活<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class MacInterface &#123;</span><br><span class="line">        public void typeC()&#123;</span><br><span class="line">            System.out.println(&quot;type 已经连接..&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public interface Monitor &#123;</span><br><span class="line"></span><br><span class="line">     void hdml();</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
<li>类适配<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class ExtendUtil extends MacInterface implements Monitor &#123;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void hdml() &#123;</span><br><span class="line">        super.typeC();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>对象适配<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class ExtendUtilV2 implements Monitor&#123;</span><br><span class="line">    private MacInterface macInterface;</span><br><span class="line">    public ExtendUtilV2()&#123;</span><br><span class="line">        macInterface &#x3D;new MacInterface();</span><br><span class="line">    &#125;</span><br><span class="line">    @Override</span><br><span class="line">    public void hdml() &#123;</span><br><span class="line">        macInterface.typeC();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>测试代码<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class Main  &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        &#x2F;&#x2F; 类适配模式</span><br><span class="line">        ExtendUtil extendUtil &#x3D;new ExtendUtil();</span><br><span class="line">        extendUtil.hdml();</span><br><span class="line">        &#x2F;&#x2F; 对象适配模式</span><br><span class="line">        ExtendUtilV2 extendUtilV2 &#x3D;new ExtendUtilV2();</span><br><span class="line">        extendUtilV2.hdml();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<img src="https://dmr-blog.oss-cn-shanghai.aliyuncs.com/blog/image_1586158475272.png" alt="image.png"></li>
</ul>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ul>
<li>优点</li>
</ul>
<ol>
<li>复用性好,可以适配系统中已经存在的方法,无需重写</li>
<li>扩展性好,可以在适配类中添加想要适配的方法</li>
</ol>
<ul>
<li>缺点</li>
</ul>
<ol>
<li>系统中一旦适配类变多则导致系统代码混乱。代码晦涩难懂</li>
</ol>
]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title>设计模式 创建型模式 单例模式</title>
    <url>/2020/08/02/%E3%80%90%E5%88%9B%E5%BB%BA%E5%9E%8B%E6%A8%A1%E5%BC%8F%E3%80%91%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<h3 id="描述"><a href="#描述" class="headerlink" title="描述"></a>描述</h3><p> 单例模式对于开发人员来讲并不陌生通过单利模式可以控制应用程序中,只有一个对象的实例,分为饿汉式和懒汉式.饿汉式在类加载的时候就初始化,懒汉模式拥有延迟加载的思想,在使用的时候创建。实现单例模式的思想就是私有构造方法。通过getInstance()方法获取对应实例<br> <span id="more"></span></p>
<h3 id="饿汉式"><a href="#饿汉式" class="headerlink" title="饿汉式"></a>饿汉式</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class Singleton&#123;</span><br><span class="line"> private static final Singleton singleton &#x3D;new Singleton();</span><br><span class="line">private Singleton&#123;</span><br><span class="line"> &#125;</span><br><span class="line"> public static Singleton getInstance()&#123;</span><br><span class="line"> return singleton;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="懒汉式"><a href="#懒汉式" class="headerlink" title="懒汉式"></a>懒汉式</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class Singleton&#123;</span><br><span class="line"> private static final singleton &#x3D; null;</span><br><span class="line">private Singleton&#123;</span><br><span class="line"> &#125;</span><br><span class="line">  private Singleton&#123;</span><br><span class="line">  &#125;</span><br><span class="line">public static Singleton getInstance()&#123;</span><br><span class="line">if(null&#x3D;&#x3D;singleton)&#123;</span><br><span class="line"> singleton &#x3D;new Singleton();</span><br><span class="line">&#125;</span><br><span class="line">return singleton;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面的实现方式在多线程的环境下是线程不安全的,下面来个线程安全的</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class Singleton&#123;</span><br><span class="line">&#x2F;&#x2F; volatile 保证每次都从主内存中取,不会在工作线程内存中取,效率不高</span><br><span class="line"> private static volatile final singleton &#x3D; null;</span><br><span class="line">  private Singleton&#123;</span><br><span class="line">  &#125;</span><br><span class="line">public static Singleton getInstance()&#123;</span><br><span class="line">if(null&#x3D;&#x3D;singleton)&#123;</span><br><span class="line">   &#x2F;&#x2F;双重锁检查</span><br><span class="line">   synchronized(Singleton.class) &#123;</span><br><span class="line">    if(null&#x3D;&#x3D;singleton)&#123;</span><br><span class="line">         singleton &#x3D;new Singleton();</span><br><span class="line">    &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">return singleton;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>下面是利用jvm加载静态内部类的方式实现单例模式.jvm初始化类</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class Singleton&#123;</span><br><span class="line">  private static class SingletonHodle&#123;</span><br><span class="line">   private static Singleton singleton &#x3D;new Singleton();</span><br><span class="line">public static getInstance()&#123;</span><br><span class="line">&#x2F;&#x2F; 保证jvm加载SingletonHodle初始Singleton实例</span><br><span class="line">return SingletonHodle.singleton;</span><br><span class="line">  &#125;</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>使用枚举实现单子例模式</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public enum Singleton &#123;</span><br><span class="line">    uniqueInstance;&#x2F;&#x2F; 定义一个枚举的元素，它就代表了Singleton的一个实例,因为枚举在编译成class文件,对应的属性就是 static final的保证了jvm初始化类的时候只能生成一个实例</span><br><span class="line">    public void singletonOperation() &#123;</span><br><span class="line">        &#x2F;&#x2F; 功能处理</span><br><span class="line">        System.err.println(&quot;功能处理&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="破快单利模式的三种方式"><a href="#破快单利模式的三种方式" class="headerlink" title="破快单利模式的三种方式"></a>破快单利模式的三种方式</h3><ul>
<li>序列化</li>
<li>反射</li>
<li>clone<h3 id="如何避免单利模式被破快"><a href="#如何避免单利模式被破快" class="headerlink" title="如何避免单利模式被破快"></a>如何避免单利模式被破快</h3></li>
<li>序列化<br>增加readResolve()方法,返回实例对象</li>
<li>反射<br>创建标志位,is_create标志,如果is_create=true 则抛异常</li>
<li>clone<br>重写clone方法,返回对应的instance </li>
</ul>
<h3 id="jdk的实现"><a href="#jdk的实现" class="headerlink" title="jdk的实现"></a>jdk的实现</h3><p>我们 JDK 中，java.lang.Runtime 就是经典的单例模式(饿汉式)</p>
]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title>设计模式 创建型模式 创建者模式</title>
    <url>/2020/07/25/%E3%80%90%E5%88%9B%E5%BB%BA%E5%9E%8B%E6%A8%A1%E5%BC%8F%E3%80%91%20%E5%88%9B%E5%BB%BA%E8%80%85%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><p>1、定义：将一个复杂对象的构建与它的表示分离，使得同样的构建过程可以创建不同的表示<br>2、主要作用：在用户不知道对象的建造过程和细节的情况下就可以直接创建复杂的对象。<br>3、如何使用：用户只需要给出指定复杂对象的类型和内容，建造者模式负责按顺序创建复杂对象（把内部的建造过程和细节隐藏起来）<br>4、解决的问题：<br>（1）、方便用户创建复杂的对象（不需要知道实现过程）<br>（2）、代码复用性 &amp; 封装性（将对象构建过程和细节进行封装 &amp; 复用）<br>5、注意事项：与工厂模式的区别是：建造者模式更加关注与零件装配的顺序，一般用来创建更为复杂的对象</p>
<span id="more"></span>
<h3 id="实现方式"><a href="#实现方式" class="headerlink" title="实现方式"></a>实现方式</h3><h3 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h3><ul>
<li><p>抽象建造者（builder）：描述具体建造者的公共接口，一般用来定义建造细节的方法，并不涉及具体的对象部件的创建。</p>
</li>
<li><p>具体建造者（ConcreteBuilder）：描述具体建造者，并实现抽象建造者公共接口。</p>
</li>
<li><p>指挥者（Director）：调用具体建造者来创建复杂对象（产品）的各个部分，并按照一定顺序（流程）来建造复杂对象。</p>
</li>
<li><p>产品（Product）：描述一个由一系列部件组成较为复杂的对象。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line"> * Builder.java</span><br><span class="line"> *  建造者</span><br><span class="line"> *&#x2F;</span><br><span class="line">abstract class Builder &#123;</span><br><span class="line">    &#x2F;&#x2F;地基</span><br><span class="line">    abstract void bulidA();</span><br><span class="line">    &#x2F;&#x2F;钢筋工程</span><br><span class="line">    abstract void bulidB();</span><br><span class="line">    &#x2F;&#x2F;铺电线</span><br><span class="line">    abstract void bulidC();</span><br><span class="line">    &#x2F;&#x2F;粉刷</span><br><span class="line">    abstract void bulidD();</span><br><span class="line">    &#x2F;&#x2F;完工-获取产品</span><br><span class="line">    abstract Product getProduct();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line"> * Product.java</span><br><span class="line"> *  产品（房子）</span><br><span class="line"> *&#x2F;</span><br><span class="line">public class Product &#123;</span><br><span class="line">    private String buildA;</span><br><span class="line">    private String buildB;</span><br><span class="line">    private String buildC;</span><br><span class="line">    private String buildD;</span><br><span class="line">    public String getBuildA() &#123;</span><br><span class="line">        return buildA;</span><br><span class="line">    &#125;</span><br><span class="line">    public void setBuildA(String buildA) &#123;</span><br><span class="line">        this.buildA &#x3D; buildA;</span><br><span class="line">    &#125;</span><br><span class="line">    public String getBuildB() &#123;</span><br><span class="line">        return buildB;</span><br><span class="line">    &#125;</span><br><span class="line">    public void setBuildB(String buildB) &#123;</span><br><span class="line">        this.buildB &#x3D; buildB;</span><br><span class="line">    &#125;</span><br><span class="line">    public String getBuildC() &#123;</span><br><span class="line">        return buildC;</span><br><span class="line">    &#125;</span><br><span class="line">    public void setBuildC(String buildC) &#123;</span><br><span class="line">        this.buildC &#x3D; buildC;</span><br><span class="line">    &#125;</span><br><span class="line">    public String getBuildD() &#123;</span><br><span class="line">        return buildD;</span><br><span class="line">    &#125;</span><br><span class="line">    public void setBuildD(String buildD) &#123;</span><br><span class="line">        this.buildD &#x3D; buildD;</span><br><span class="line">    &#125;</span><br><span class="line">    @Override</span><br><span class="line">        public String toString() &#123;</span><br><span class="line">            return buildA+&quot;\n&quot;+buildB+&quot;\n&quot;+buildC+&quot;\n&quot;+buildD+&quot;\n&quot;+&quot;房子验收完成&quot;;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line"> * ConcreteBuilder.java</span><br><span class="line"> *  具体建造者(工人)</span><br><span class="line"> *&#x2F;</span><br><span class="line">public class ConcreteBuilder extends Builder&#123;</span><br><span class="line">    private Product product;</span><br><span class="line">    public ConcreteBuilder() &#123;</span><br><span class="line">        product &#x3D; new Product();</span><br><span class="line">    &#125;</span><br><span class="line">    @Override</span><br><span class="line">    void bulidA() &#123;</span><br><span class="line">        product.setBuildA(&quot;地基&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    @Override</span><br><span class="line">    void bulidB() &#123;</span><br><span class="line">        product.setBuildB(&quot;钢筋工程&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    @Override</span><br><span class="line">    void bulidC() &#123;</span><br><span class="line">        product.setBuildC(&quot;铺电线&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    @Override</span><br><span class="line">    void bulidD() &#123;</span><br><span class="line">        product.setBuildD(&quot;粉刷&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    @Override</span><br><span class="line">    Product getProduct() &#123;</span><br><span class="line">        return product;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">&#x2F;**</span><br><span class="line"> * Director.java</span><br><span class="line"> *  指挥者</span><br><span class="line"> *&#x2F;</span><br><span class="line">public class Director &#123;</span><br><span class="line">    &#x2F;&#x2F;指挥工人按顺序造房</span><br><span class="line">    public Product create(Builder builder) &#123;</span><br><span class="line">        builder.bulidA();</span><br><span class="line">        builder.bulidB();</span><br><span class="line">        builder.bulidC();</span><br><span class="line">        builder.bulidD();</span><br><span class="line">        return builder.getProduct();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line"> * Test.java</span><br><span class="line"> *  测试类</span><br><span class="line"> *&#x2F;</span><br><span class="line">public class Test &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        Director director &#x3D; new Director();</span><br><span class="line">        Product create &#x3D; director.create(new ConcreteBuilder());</span><br><span class="line">        System.out.println(create.toString());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3></li>
</ul>
<ol>
<li>Builder 抽象类定义构建的方法</li>
<li>具体实现类实现Builder相关的方法-叫具体建造者</li>
<li>指挥者操作操作具体建造者按照顺序创建对象</li>
<li>产品类有大量属性<h4 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h4></li>
</ol>
<ul>
<li>按照顺序创建对象</li>
<li>创建代码可读性好</li>
<li>隐藏对象大量属性,可以设置一些属性的默认值<h4 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h4></li>
<li>代码冗余</li>
<li>具体建造者内部代码复杂,代码可读性差<h4 id="具体实现"><a href="#具体实现" class="headerlink" title="具体实现"></a>具体实现</h4></li>
<li>protobuf生成的实体类<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SimpleRequest.Builder builder &#x3D; SimpleRequest.newBuilder();</span><br><span class="line">builder.setId(12341);</span><br><span class="line">builder.setName(&quot;你好&quot;);</span><br><span class="line">SimpleRequest request &#x3D; builder.build();</span><br></pre></td></tr></table></figure></li>
</ul>
]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title>设计模式 创建型模式 抽象方法模式</title>
    <url>/2020/07/20/%E3%80%90%E5%88%9B%E5%BB%BA%E5%9E%8B%E6%A8%A1%E5%BC%8F%E3%80%91%E6%8A%BD%E8%B1%A1%E6%96%B9%E6%B3%95%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><p> 抽象方法模式是工厂方法模式的一种扩展,最简单的抽象方法模式会退化成了工厂方法模式,抽象方法模式提出了产品族的一个概念。那么什么是产品族呢？还是以汽车为例,汽车是一个产品的抽象,汽车的型号就是汽车的产品族比如,suv,轿车,跑车。如果工厂模式创建的不是一个简单的产品,而是多个产品族的情况,那么就需要使用抽象方法模式<br> <span id="more"></span></p>
<h3 id="类图"><a href="#类图" class="headerlink" title="类图"></a>类图</h3><p>抽象方法模式需要以下几个角色</p>
<ul>
<li><p>抽象工厂类</p>
</li>
<li><p>产品工厂类</p>
</li>
<li><p>抽象产品类</p>
</li>
<li><p>产品类<br><img src="https://dmr-blog.oss-cn-shanghai.aliyuncs.com/blog/image_1585581293704.png" alt="image.png"></p>
<h3 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public abstract class  AbstractCarFactory &#123;</span><br><span class="line">        abstract void buildSuv();</span><br><span class="line">        abstract void buildJiaoche();</span><br><span class="line">        abstract void buildYueYeChe();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>public class BaoJunCarFactory extends AbstractCarFactory {<br>  private BaojunCar baojunCar=new BaojunCar();<br>  @Override<br>  void buildSuv() {</p>
<pre><code>  baojunCar.suv();
</code></pre>
<p>  }</p>
<p>  @Override<br>  void buildJiaoche() {</p>
<pre><code>  baojunCar.jiaoche();
</code></pre>
<p>  }</p>
<p>  @Override<br>  void buildYueYeChe() {</p>
<pre><code>  baojunCar.yueyeche();
</code></pre>
<p>  }<br>}</p>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class BMWCarFactory extends AbstractCarFactory &#123;</span><br><span class="line"></span><br><span class="line">    private BMWCar bmwCar &#x3D;new BMWCar();</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    void buildSuv() &#123;</span><br><span class="line">        bmwCar.suv();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    void buildJiaoche() &#123;</span><br><span class="line">        bmwCar.jiaoche();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    void buildYueYeChe() &#123;</span><br><span class="line">        bmwCar.yueyeche();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class BaojunCar implements Car &#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void yueyeche() &#123;</span><br><span class="line">        System.out.println(&quot;宝骏 越野车&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void jiaoche() &#123;</span><br><span class="line">        System.out.println(&quot;宝骏 轿车&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void suv() &#123;</span><br><span class="line">        System.out.println(&quot;宝骏 suv&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class BMWCar implements Car &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void yueyeche() &#123;</span><br><span class="line">        System.out.println(&quot;宝马 越野车&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void jiaoche() &#123;</span><br><span class="line">        System.out.println(&quot;宝马 轿车&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void suv() &#123;</span><br><span class="line">        System.out.println(&quot;宝马 suv&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public interface Car &#123;</span><br><span class="line">    void yueyeche();</span><br><span class="line">    void jiaoche();</span><br><span class="line">    void suv();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class Main &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        BaoJunCarFactory baoJunCarFactory &#x3D;new BaoJunCarFactory();</span><br><span class="line">        baoJunCarFactory.buildJiaoche();</span><br><span class="line">        baoJunCarFactory.buildSuv();</span><br><span class="line">        baoJunCarFactory.buildYueYeChe();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        BMWCarFactory bmwCarFactory &#x3D;new BMWCarFactory();</span><br><span class="line">        bmwCarFactory.buildJiaoche();</span><br><span class="line">        bmwCarFactory.buildSuv();</span><br><span class="line">        bmwCarFactory.buildYueYeChe();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看到我们的抽象工厂定义了多个抽象方法,这也就是为什么叫抽象方法模式的原因了。实际上和工厂方法模式一样。只是有产品族抽象方法的概念</p>
<h3 id="优缺点"><a href="#优缺点" class="headerlink" title="优缺点"></a>优缺点</h3><h4 id="优点："><a href="#优点：" class="headerlink" title="优点："></a>优点：</h4><ul>
<li>复合高内聚低耦合的开发设计规范,抽象工厂模式将创建产品的逻辑收敛起来,如果更换产品只需要选择对应的工厂方法即可</li>
<li>增加具体产品工厂和产品很方便</li>
<li>当产品族中的多个对象一起工作的时候,客户端只能使用同一个产品族的对象<h4 id="缺点："><a href="#缺点：" class="headerlink" title="缺点："></a>缺点：</h4></li>
<li>开闭原则的倾斜性,增加产品和产品工厂很方便,增加产品族很困难,所以设计抽象方法的时候一定要尽可能多的设计抽象方法</li>
</ul>
<h3 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h3><p>客户端切换界面主题, 各个控件对象的构造过程都收敛到同一个工厂类中</p>
]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title>设计模式 创建型模式 简单工厂模式</title>
    <url>/2020/07/11/%E3%80%90%E5%88%9B%E5%BB%BA%E5%9E%8B%E6%A8%A1%E5%BC%8F%E3%80%91%E7%AE%80%E5%8D%95%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><p>简单工厂模式又叫静态工厂模式,是属于创建型模式,工厂方法通过参数来控制创建不通的对象,这些对象都继承同一个夫类。</p>
<h3 id="类图"><a href="#类图" class="headerlink" title="类图"></a>类图</h3><p><img src="https://dmr-blog.oss-cn-shanghai.aliyuncs.com/blog/image_1585579314830.png" alt="image.png"></p>
<span id="more"></span>
<h3 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class CarFactory &#123;</span><br><span class="line"></span><br><span class="line">    public static Car getCar(String name) &#123;</span><br><span class="line">        if (&quot;BMW&quot;.equals(name)) &#123;</span><br><span class="line">            return new BMWCar();</span><br><span class="line">        &#125;</span><br><span class="line">        if (&quot;BAOJUN&quot;.equals(name)) &#123;</span><br><span class="line">            return new BaojunCar();</span><br><span class="line">        &#125;</span><br><span class="line">        throw new RuntimeException(&quot;unsupport car name &quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public interface Car &#123;</span><br><span class="line">    void desc();</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class BMWCar implements Car &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void desc() &#123;</span><br><span class="line">        System.out.println(&quot;我是宝马～&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class BaojunCar implements Car &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void desc() &#123;</span><br><span class="line">        System.out.println(&quot;我是宝骏！&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol>
<li>产品类（宝马、宝骏）都继承Car类</li>
<li>工厂类根据入参不同返回不通的产品<br>下面是主方法<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class Main &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        Car bmw &#x3D; CarFactory.getCar(&quot;BMW&quot;);</span><br><span class="line">        bmw.desc();</span><br><span class="line">        Car baojun &#x3D; CarFactory.getCar(&quot;BAOJUN&quot;);</span><br><span class="line">        baojun.desc();</span><br><span class="line">        Car xxx &#x3D; CarFactory.getCar(&quot;xxx&quot;);</span><br><span class="line">        xxx.desc();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
结果：<br><img src="https://dmr-blog.oss-cn-shanghai.aliyuncs.com/blog/image_1585578451696.png" alt="image.png"></li>
</ol>
<h3 id="优缺点"><a href="#优缺点" class="headerlink" title="优缺点"></a>优缺点</h3><h4 id="优点："><a href="#优点：" class="headerlink" title="优点："></a>优点：</h4><ul>
<li>通过入参控制返回不同的产品,隐藏生成产品的逻辑,调用方属于消费者</li>
<li>调用方只需要记录相关类的参数即可创建对应的类,避免了创建类名复杂,不好记忆的问题</li>
<li>相关参数可以放到配置文件中,一定成都上增加了灵活性<h4 id="缺点："><a href="#缺点：" class="headerlink" title="缺点："></a>缺点：</h4></li>
<li>所有的类创建都在工厂类创建,一但工厂类发生问题所有的产品的创建都受到影响</li>
<li>扩展性差,如果增加新的产品需要在工厂类增加代码,导致工厂类过于复杂且庞大</li>
<li>产品的创建基于静态方法,造成产品无法形成基于继承的等级结构<h3 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h3></li>
</ul>
<ol>
<li>加密场景 KeyGenerator keyGen=KeyGenerator.getInstance(“DESede”);</li>
<li>DateFormat JDK类库中广泛使用了简单工厂模式，如工具类java.text.DateFormat，它用于格式化一个本地日期或者时间。</li>
</ol>
<h4 id="参考地址"><a href="#参考地址" class="headerlink" title="参考地址"></a>参考地址</h4><ul>
<li><a href="https://design-patterns.readthedocs.io/zh_CN/latest/creational_patterns/simple_factory.html">图说设计模式</a></li>
<li><a href="http://canyuda.top/posts/2019090532068/">设计模式-简单工厂模式</a></li>
</ul>
]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title>设计模式 七大设计原则</title>
    <url>/2020/06/29/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%20%E4%B8%83%E5%A4%A7%E8%AE%BE%E8%AE%A1%E5%8E%9F%E5%88%99/</url>
    <content><![CDATA[<p>下面是我对7大设计原则自己的理解</p>
<ul>
<li>单一原则<br>一个类只做一件事情</li>
<li>里氏替换原则<br>1.合理继承<br>2.继承 子类是为了扩展父类,而不是重写相关方法。</li>
<li>依赖倒置原则<br>高模块不应该直接依赖低模块,而是应该依赖其抽象</li>
<li>开闭原则<br>对扩展开放,对修改关闭</li>
<li>迪莱米原则<br>一个类引用类一个类,被引用类应该尽可能的封装自己的属性和方法,让别的类知道的越少越好</li>
<li>组合复合原则<br>不推荐使用继承,可以使用组合的方式进行实现</li>
<li>接口隔离原则<br>一个类对于另一个类的依赖,应该建立在最小的接口上,使用接口隔离</li>
</ul>
]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title>java 基础知识 动态代理 cglib代理</title>
    <url>/2020/06/25/java%20%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86-%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86-cglib%E4%BB%A3%E7%90%86/</url>
    <content><![CDATA[<h3 id="一、cglib代理介绍"><a href="#一、cglib代理介绍" class="headerlink" title="一、cglib代理介绍"></a>一、cglib代理介绍</h3><p>cglib代理是实现动态代理的另一种方式,CGLIB是一个功能强大，高性能的代码生成包。它为没有实现接口的类提供代理，为JDK的动态代理提供了很好的补充。通常可以使用Java的动态代理创建代理，但当要代理的类没有实现接口或者为了更好的性能，CGLIB是一个好的选择</p>
<h3 id="二、cglib的原理"><a href="#二、cglib的原理" class="headerlink" title="二、cglib的原理"></a>二、cglib的原理</h3><ol>
<li>动态生成目标类的代理类,重写代理类的所有非final修饰的方法,子类使用方法拦截的方式实现目标类的增强,所以cglib代理比jdk反射代理效率更高,并且能代理类,而jdk代理只能代理接口</li>
<li>底层使用asm字节码框架生成代理类,而不是使用反射生成类</li>
<li>缺点不能代理被final修饰的方法  <span id="more"></span>
<h3 id="三、cglib代理的实现"><a href="#三、cglib代理的实现" class="headerlink" title="三、cglib代理的实现"></a>三、cglib代理的实现</h3><pre><code>public static void main(String[] args) &#123;
     System.setProperty(DebuggingClassWriter.DEBUG_LOCATION_PROPERTY, &quot;resource&quot;);
     Dog dog =new Dog();
     Enhancer enhancer =new Enhancer();
     //设置目前类
     enhancer.setSuperclass(Dog.class);
     //设置拦截器
     enhancer.setCallback(new MethodInterceptor() &#123;
         public Object intercept(Object o, Method method, Object[] objects, MethodProxy methodProxy) throws Throwable &#123;
             System.out.println(&quot;呵呵,我是增强&quot;);
             return  methodProxy.invokeSuper(o,objects);
         &#125;
     &#125;);
     Dog dogProxy = (Dog) enhancer.create();
     dogProxy.run();
 &#125;
</code></pre>
</li>
</ol>
<h3 id="四、invokeSuper-方法"><a href="#四、invokeSuper-方法" class="headerlink" title="四、invokeSuper()方法"></a>四、invokeSuper()方法</h3><p>因为cglib代理是继承目标类,并且重写方法,所以这里调用invokesuper方法,调用父类的方法  </p>
<h3 id="五、cglib原理"><a href="#五、cglib原理" class="headerlink" title="五、cglib原理"></a>五、cglib原理</h3><p><img src="https://dmr-blog.oss-cn-shanghai.aliyuncs.com/blog/image-9d6ebe185caf41dabf565fc34cf4261e.png" alt="image.png"><br>上图可以看到cglib方式会在内存中生成,3个字节码文件.可以使用 System.setProperty(DebuggingClassWriter.DEBUG_LOCATION_PROPERTY, “resource”);方法将字节码文件写到相关目录。</p>
<ol>
<li>可以看到代理类实现了目标代理类<br><img src="https://dmr-blog.oss-cn-shanghai.aliyuncs.com/blog/image-c8f1d330468b43cf8c7c366de820eb60.png" alt="image.png"></li>
<li>可以看到重写run方法,先回去回调方法,如果获取不到就加载回调方法,执行intercept 方法<br><img src="https://dmr-blog.oss-cn-shanghai.aliyuncs.com/blog/image-b8c6e2ef41bf4aae9d284e0917377c86.png" alt="image.png"></li>
<li>FastClass机制<br>FastClass提出了index下标的概念,通过index保存方法的引用信息,将反射调用转化为方法的直接调用,体现所谓的fast<br><img src="https://dmr-blog.oss-cn-shanghai.aliyuncs.com/blog/image-9d8363bf512c4056b006d7b3180fae63.png" alt="image.png"></li>
<li>通过方法名计算hashcode值,通过hashcode找到方法对应的index</li>
<li>通过index 调用invoke方法,invoke方法通过index判断执行那个方法  </li>
</ol>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ol>
<li>动态代理类通过实现invocationHandler接口</li>
<li>通过<br>Proxy.newProxyInstance(factory.getClass().getClassLoader(),person.getClass().getInterfaces(),this)方法<br>复制一份代理的类并且生成字节码文件到内存中,<br>生成的代理类 继承了Proxy类 并且实现了代理接口<br>调用生成的动态代理类中实现的方法,其中调用了其实现的方法，在方法中通过invocationHandler的invoke()方法<br>jdk动态代理的缺点 不能代理类,需要实现invocationHandler接口<br>jdk动态代理和cglib生成字节码的方式不通</li>
<li>cglib动态代理 可以动态代理类<br>因为cglib动态生成的类是继承原类,所以可以动态代理到类</li>
<li>jdk动态代理实现了自己的顶层接口继承了proxy类</li>
</ol>
]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>java基础</tag>
      </tags>
  </entry>
  <entry>
    <title>java 基础知识 动态代理 jdk代理</title>
    <url>/2020/06/15/java%20%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86-%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86-jdk%E4%BB%A3%E7%90%86/</url>
    <content><![CDATA[<h3 id="一、jdk动态代理"><a href="#一、jdk动态代理" class="headerlink" title="一、jdk动态代理"></a>一、jdk动态代理</h3><p>动态代理分为jdk动态代理和cglib动态代理,本章讲解jdk动态代理</p>
<h3 id="二、jdk动态代理如何实现"><a href="#二、jdk动态代理如何实现" class="headerlink" title="二、jdk动态代理如何实现"></a>二、jdk动态代理如何实现</h3><ol>
<li>实现InvorcationHander接口,在invoke()方法实现增强</li>
<li>通过Proxy.newProxyInstance()方法获取到代理类</li>
<li>调用代理引用调用目标方法实现曾江<span id="more"></span>
<h3 id="三、代码实现"><a href="#三、代码实现" class="headerlink" title="三、代码实现"></a>三、代码实现</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">        final Car car &#x3D; new BmwCar();</span><br><span class="line">        Car carProxy &#x3D; (Car) Proxy.newProxyInstance(Car.class.getClassLoader(), car.getClass().getInterfaces(), new InvocationHandler() &#123;</span><br><span class="line">            public Object invoke(Object proxy, Method method, Object[] args) throws Throwable &#123;</span><br><span class="line">                System.out.println(&quot;增强前&quot;);</span><br><span class="line">                Object invoke &#x3D; method.invoke(car, args);</span><br><span class="line">                System.out.println(&quot;增强后&quot;);</span><br><span class="line">                return invoke;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        carProxy.run();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
结果:<br><img src="https://dmr-blog.oss-cn-shanghai.aliyuncs.com/blog/image-bd78b9420f1948c1a40d2296a963968d.png" alt="image.png"><h3 id="四、实现原理"><a href="#四、实现原理" class="headerlink" title="四、实现原理"></a>四、实现原理</h3><img src="https://dmr-blog.oss-cn-shanghai.aliyuncs.com/blog/image-662f7405a32640d18fc980a2cfa0f0a5.png" alt="image.png"><br><img src="https://dmr-blog.oss-cn-shanghai.aliyuncs.com/blog/image-5655df9945ac46fbbdfcc732096d9617.png" alt="image.png"><br><img src="https://dmr-blog.oss-cn-shanghai.aliyuncs.com/blog/image-26944ac2f4124595a0488f9839f89d05.png" alt="image.png"><br><img src="https://dmr-blog.oss-cn-shanghai.aliyuncs.com/blog/image-a1db2b12ab37483881d89a6ef1738e0f.png" alt="image.png"><br>可以看到通过Proxy.newProxyInstance()生成了目标对象的代理类,以二进制的方式加载到了内存中.<br>那么代理类长什么样子呢？<br><img src="https://dmr-blog.oss-cn-shanghai.aliyuncs.com/blog/image-e76f3aae567d4aeb8f3e6d1b5f07bfc2.png" alt="image.png"></li>
<li>代理类继承了Proxy类并且实现了我们的car接口</li>
<li>在实现的run方法中,调用了h.invoke()方法</li>
<li>那么h是什么呢？ h是 Proxy类中的属性,就是InvoketionHander接口的引用,所以jdk代理类必须实现InvoketionHander接口<br><img src="https://dmr-blog.oss-cn-shanghai.aliyuncs.com/blog/image-5dd41bac7c5244c895bf1b375ff8db00.png" alt="image.png"><br>jdk 动态代理实现图<br><img src="https://dmr-blog.oss-cn-shanghai.aliyuncs.com/blog/image-29ce1ec01db5495c8101137d1bc51028.png" alt="image.png"></li>
</ol>
]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>java基础</tag>
      </tags>
  </entry>
  <entry>
    <title>java 基础知识 静态代理</title>
    <url>/2020/06/11/%20java%20%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86-%E9%9D%99%E6%80%81%E4%BB%A3%E7%90%86/</url>
    <content><![CDATA[<h3 id="一、什么是代理模式"><a href="#一、什么是代理模式" class="headerlink" title="一、什么是代理模式"></a>一、什么是代理模式</h3><ul>
<li>定义<br>给目标对象提供一个代理对象,由代理对象操作目标对象的引用。</li>
<li>目的<br>通过操作代理对象,操作目标对象,降低程序的复杂性,可以使用代理类实现目标对象的增强。不改变目标对象实现功能则增加。代理模式的结构图</li>
</ul>
<p><img src="https://dmr-blog.oss-cn-shanghai.aliyuncs.com/blog/image-c4b34c32767f4621a2cfc188a670c1fa.png" alt="image.png"></p>
<span id="more"></span>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">graph LR;</span><br><span class="line">bwmcar--&gt;car </span><br><span class="line">bwmcar--&gt;bwmproxy </span><br><span class="line">bwmproxy--&gt;car</span><br></pre></td></tr></table></figure>
<h3 id="二、java实现"><a href="#二、java实现" class="headerlink" title="二、java实现"></a>二、java实现</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;定义一个接口</span><br><span class="line">public interface Car &#123;</span><br><span class="line">    public void run() ;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;定义宝马车实现类</span><br><span class="line">public class BmwCar implements Car &#123;</span><br><span class="line">    public void run() &#123;</span><br><span class="line">        System.out.println(&quot;我是一个宝马车&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;定义宝马车实现类</span><br><span class="line">public class BmwCarProxy implements Car &#123;</span><br><span class="line">    &#x2F;&#x2F;代理类拥有目标对象的引用</span><br><span class="line">    private BmwCar bmwCar;</span><br><span class="line"></span><br><span class="line">    public void proxy(BmwCar bmwCar) &#123;</span><br><span class="line">        this.bmwCar &#x3D; bmwCar;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void run() &#123;</span><br><span class="line">        System.out.println(&quot;增强前&quot;);</span><br><span class="line">        bmwCar.run();</span><br><span class="line">        System.out.println(&quot;增强后&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">       BmwCar bmwCar &#x3D;new BmwCar();</span><br><span class="line">       BmwCarProxy proxy &#x3D;new BmwCarProxy();</span><br><span class="line">       proxy.proxy(bmwCar);</span><br><span class="line"> &#x2F;&#x2F;调用代理类的方法  </span><br><span class="line">     proxy.run();</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<p><img src="https://dmr-blog.oss-cn-shanghai.aliyuncs.com/blog/image-a5e40f4c878a462e84697245290394f1.png" alt="image.png"></p>
<h3 id="三、总结"><a href="#三、总结" class="headerlink" title="三、总结"></a>三、总结</h3><ol>
<li>静态代理模式可以在不改变目标对象的前提下,对目标对象实现方法的增加</li>
<li>每次增加增强方法都需要修改代码,违反开闭原则,扩展能力可维护性查</li>
</ol>
]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>java基础</tag>
        <tag>静态代理</tag>
      </tags>
  </entry>
  <entry>
    <title>java NIO 相关(七) nio selector channel 的多路复用器</title>
    <url>/2020/05/30/java%20NIO%E7%9B%B8%E5%85%B3(%E4%B8%83)%20nio%20selector(channel%20%E7%9A%84%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8%E5%99%A8)/</url>
    <content><![CDATA[<h3 id="一、概念"><a href="#一、概念" class="headerlink" title="一、概念"></a>一、概念</h3><p>选择器（selector）是selectableChannel对象的多路复用器,一个selector可以监控多个selectableChannel的io情况,selector可以实现一个线程单独管理多个channel,selector是非阻塞的核心</p>
<span id="more"></span>
<h3 id="二、selector可以监控的事件类型"><a href="#二、selector可以监控的事件类型" class="headerlink" title="二、selector可以监控的事件类型"></a>二、selector可以监控的事件类型</h3><ol>
<li>connect 客户端连接服务端事件</li>
<li>accept 服务端接受服务端事件</li>
<li>read   读事件</li>
<li>write  写事件  </li>
</ol>
<p>每次请求都是从客户端连接服务端(connect),服务端开始准备(accept),准备完成后开始读数据,处理完成之后再写数据</p>
<h3 id="三、selector的常用方法"><a href="#三、selector的常用方法" class="headerlink" title="三、selector的常用方法"></a>三、selector的常用方法</h3><p><img src="https://dmr-blog.oss-cn-shanghai.aliyuncs.com/blog/image-22c6aa2f552a4064b9f051c9520d9917.png" alt="image.png"></p>
<h3 id="四、nio-的例子"><a href="#四、nio-的例子" class="headerlink" title="四、nio 的例子"></a>四、nio 的例子</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;服务端</span><br><span class="line">public class NioServer &#123;</span><br><span class="line">    private ServerSocketChannel serverSocketChannel;</span><br><span class="line">    private Selector selector;</span><br><span class="line">    private Integer port &#x3D; 8080;</span><br><span class="line"></span><br><span class="line">    NioServer() &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            serverSocketChannel &#x3D; ServerSocketChannel.open().bind(new InetSocketAddress(port));</span><br><span class="line">            &#x2F;&#x2F;设置非阻塞</span><br><span class="line">            serverSocketChannel.configureBlocking(false);</span><br><span class="line">            &#x2F;&#x2F;创建Selector</span><br><span class="line">            selector &#x3D; Selector.open();</span><br><span class="line">            &#x2F;&#x2F;注册tcp 连接事件到 channel</span><br><span class="line">            serverSocketChannel.register(selector, SelectionKey.OP_ACCEPT);</span><br><span class="line">            System.out.println(&quot;服务端初始化完成,端口号:&quot; + port);</span><br><span class="line">        &#125; catch (Exception ex) &#123;</span><br><span class="line">            throw new RuntimeException(&quot;初始化服务端失败,ex:&quot;+ex);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private void start() &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            &#x2F;&#x2F;获取查看selector 管理多少个channel</span><br><span class="line">            while (selector.select() &gt; 0) &#123;</span><br><span class="line">                &#x2F;&#x2F;走到这里肯定是selector发现channel有变化了,这个大哥把他管理的sekectedKeys拿出来遍历</span><br><span class="line">                Set&lt;SelectionKey&gt; selectionKeys &#x3D; selector.selectedKeys();</span><br><span class="line">                Iterator&lt;SelectionKey&gt; iterator &#x3D; selectionKeys.iterator();</span><br><span class="line">                while (iterator.hasNext()) &#123;</span><br><span class="line">                    SelectionKey selectionKey &#x3D; iterator.next();</span><br><span class="line">                    &#x2F;&#x2F;selector 也不知道是什么变化所以就 各种判断一下,是 创建连接、还是准备就绪、还是读取数据、还是写数据、还是关闭连接</span><br><span class="line">                    if (selectionKey.isConnectable()) &#123;</span><br><span class="line">                        System.out.println(&quot;用户建立连接&quot;);</span><br><span class="line">                    &#125;</span><br><span class="line">                    if (selectionKey.isAcceptable()) &#123;</span><br><span class="line">                        System.out.println(&quot;用户准备就绪&quot;);</span><br><span class="line">                        ServerSocketChannel serverSocketChannel &#x3D; (ServerSocketChannel) selectionKey.channel();</span><br><span class="line">                        &#x2F;&#x2F;这样就拿到了发生变化的 socketChannel</span><br><span class="line"></span><br><span class="line">                        SocketChannel accept &#x3D; serverSocketChannel.accept();</span><br><span class="line">                        accept.configureBlocking(false);</span><br><span class="line">                        &#x2F;&#x2F;把客户端的channel 注册到 selector 当客户端的socketChannel发生变化出发读逻辑</span><br><span class="line">                        accept.register(selector, SelectionKey.OP_READ);</span><br><span class="line">                    &#125;</span><br><span class="line">                    if (selectionKey.isReadable()) &#123;</span><br><span class="line">                        System.out.println(&quot;读数据&quot;);</span><br><span class="line">                        SocketChannel socketChannel &#x3D; (SocketChannel) selectionKey.channel();</span><br><span class="line">                        &#x2F;&#x2F;读数据得是由buffer</span><br><span class="line">                        ByteBuffer byteBuffer &#x3D; ByteBuffer.allocate(1024);</span><br><span class="line">                        &#x2F;&#x2F;切换到读模式</span><br><span class="line">                        StringBuffer sb &#x3D; new StringBuffer();</span><br><span class="line">                        while (socketChannel.read(byteBuffer) !&#x3D; -1) &#123;</span><br><span class="line">                            byteBuffer.flip();</span><br><span class="line">                            sb.append(StandardCharsets.UTF_8.decode(byteBuffer));</span><br><span class="line">                            byteBuffer.clear();</span><br><span class="line">                        &#125;</span><br><span class="line">                        System.out.println(&quot;来自客户端的问候:&quot; + sb.toString());</span><br><span class="line">                        &#x2F;&#x2F;来个写数据吧</span><br><span class="line">                        socketChannel.register(selector,SelectionKey.OP_WRITE);</span><br><span class="line">                    &#125;</span><br><span class="line">                    if (selectionKey.isWritable()) &#123;</span><br><span class="line">                        System.out.println(&quot;写数据&quot;);</span><br><span class="line">                        System.out.println(&quot;不会写数据&quot;);</span><br><span class="line">                        selectionKey.channel().close();</span><br><span class="line">                    &#125;</span><br><span class="line">                    if (selectionKey.isValid()) &#123;</span><br><span class="line">                        System.out.println(&quot;关闭数据&quot;);</span><br><span class="line">                    &#125;</span><br><span class="line">                    &#x2F;&#x2F;把当前的selection移除,因为后面事件还会加入</span><br><span class="line">                    iterator.remove();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; catch (Exception ex) &#123;</span><br><span class="line">            throw new RuntimeException(&quot;服务异,ex:&quot;, ex);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        &#x2F;&#x2F;先定义服务端</span><br><span class="line">        NioServer nioServer &#x3D; new NioServer();</span><br><span class="line">        &#x2F;&#x2F;开启服务</span><br><span class="line">        nioServer.start();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;客户端</span><br><span class="line">public class NioClint &#123;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) throws IOException &#123;</span><br><span class="line">        SocketChannel open &#x3D; SocketChannel.open();</span><br><span class="line">        open.connect(new InetSocketAddress(&quot;127.0.0.1&quot;,8080));</span><br><span class="line">        open.configureBlocking(false);</span><br><span class="line">        ByteBuffer byteBuffer &#x3D;ByteBuffer.allocate(1024);</span><br><span class="line">        byteBuffer.flip();</span><br><span class="line">        String msg &#x3D;&quot;呵呵,你大爷&quot;;</span><br><span class="line">        byteBuffer &#x3D; ByteBuffer.wrap(msg.getBytes(&quot;utf-8&quot;));</span><br><span class="line">        open.write(byteBuffer);</span><br><span class="line">        byteBuffer.clear();</span><br><span class="line">        Socket socket &#x3D; open.socket();</span><br><span class="line">        SocketChannel channel &#x3D; socket.getChannel();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>NIO 系列</category>
      </categories>
      <tags>
        <tag>java基础</tag>
        <tag>NIO</tag>
      </tags>
  </entry>
  <entry>
    <title>java 基础知识 字符集</title>
    <url>/2020/05/25/%20java%20%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E7%82%B9-%E5%AD%97%E7%AC%A6%E9%9B%86md/</url>
    <content><![CDATA[<h3 id="字符集相关概念"><a href="#字符集相关概念" class="headerlink" title="字符集相关概念"></a>字符集相关概念</h3><p>编码： 字符串-&gt;字节数组 </p>
<p>解码：字节数组-&gt;字符串  </p>
<h3 id="相关字符集介绍"><a href="#相关字符集介绍" class="headerlink" title="相关字符集介绍"></a>相关字符集介绍</h3><ul>
<li><p>ASCII (american standard code for information interchange 美国信息交换标准代码)7 bit 表示来表示一个字符，共计可以表示128中字符 </p>
<span id="more"></span></li>
<li><p>Ios-8859-1 8 bit 表示一个字符 ，即使用一个字节  8 bit表示一个字符 共计可以表示 256个字符 </p>
</li>
<li><p>Gb2312 2个字节表示一个汉字 </p>
</li>
<li><p>Gbk 对 Gb2312的扩展 支持生僻字 </p>
</li>
<li><p>Gb18030 表示汉字最多的 </p>
</li>
<li><p>Big5 繁体中文 </p>
</li>
<li><p>Unicode 最广泛的编码，两个字节表示一个字符  包含全球所有文字 </p>
</li>
</ul>
<p>缺点 ： 存储空间会变大(英文国家) </p>
<ul>
<li><p>Utf unicode是一个编码方式，而utf是一个存储方式 utf-8 是unicode的实现方式之一 </p>
</li>
<li><p>Utf-16LE(小端)  UTF16BE(大端) </p>
<p>文件起始位置 0xFEFF (BE) 0XFFFE(LE) </p>
</li>
<li><p>Utf-8 变长字节表示形式 </p>
</li>
</ul>
<p>一般来说，utf-8 会通过3个字节表示一个中文 </p>
]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>字符集</tag>
        <tag>utf-8</tag>
      </tags>
  </entry>
  <entry>
    <title>java NIO 相关(六) pipe 和 FileChannel文件锁</title>
    <url>/2020/05/21/java%20NIO%E7%9B%B8%E5%85%B3(%E5%85%AD)%20pipe%20%E5%92%8C%20FileChannel%E6%96%87%E4%BB%B6%E9%94%81/</url>
    <content><![CDATA[<h3 id="一、pipe"><a href="#一、pipe" class="headerlink" title="一、pipe"></a>一、pipe</h3><h4 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h4><p> pipe 是nio管道2个线程之前的单项数据连接。<br> pipe 有2个通道一个是source通道一个是sink通道<br>数据会写入到source通道从sink通道获取数据。如图：<br><img src="https://dmr-blog.oss-cn-shanghai.aliyuncs.com/blog/image-bd9f6b5abebf408b8ce8935ceb5fe357.png" alt="image.png"></p>
<span id="more"></span>
<h4 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class PipeTest &#123;</span><br><span class="line">public static void main(String[] args) &#123;</span><br><span class="line"></span><br><span class="line">	Pipe pipe &#x3D; null;</span><br><span class="line">	ExecutorService exec &#x3D; 	Executors.newFixedThreadPool(2); </span><br><span class="line">try &#123;</span><br><span class="line">	pipe &#x3D; Pipe.open();</span><br><span class="line">	final Pipe pipeTemp &#x3D; pipe;</span><br><span class="line">	exec.submit(new Callable&lt;Object&gt;() &#123; @Override</span><br><span class="line">		public Object call() throws Exception &#123;</span><br><span class="line">		Pipe.SinkChannel sinkChannel &#x3D; pipeTemp.sink();&#x2F;&#x2F;向通道中写</span><br><span class="line">	while (true) &#123;</span><br><span class="line">		TimeUnit.SECONDS.sleep(1);</span><br><span class="line">		String newData &#x3D; &quot;Pipe Test At Time &quot; +</span><br><span class="line">		System.currentTimeMillis();</span><br><span class="line">		ByteBuffer buf &#x3D; ByteBuffer.allocate(1024);</span><br><span class="line">		buf.clear(); buf.put(newData.getBytes()); 		buf.flip();</span><br><span class="line">		while (buf.hasRemaining()) &#123; 	</span><br><span class="line">		System.out.println(buf); </span><br><span class="line">		sinkChannel.write(buf);</span><br><span class="line">	   &#125; </span><br><span class="line">   &#125;</span><br><span class="line">&#125; </span><br><span class="line">&#125;);</span><br><span class="line">	exec.submit(new Callable&lt;Object&gt;() &#123; </span><br><span class="line">	@Override</span><br><span class="line">	public Object call() throws Exception &#123;Pipe.SourceChannel sourceChannel &#x3D; pipeTemp.source();&#x2F;&#x2F;向</span><br><span class="line">	while (true) &#123;</span><br><span class="line">	TimeUnit.SECONDS.sleep(1);</span><br><span class="line">	ByteBuffer buf &#x3D; ByteBuffer.allocate(1024); </span><br><span class="line">	buf.clear();</span><br><span class="line">	int bytesRead &#x3D; sourceChannel.read(buf); 	</span><br><span class="line">	System.out.println(&quot;bytesRead&#x3D;&quot; + bytesRead); </span><br><span class="line">	while (bytesRead &gt; 0) &#123;</span><br><span class="line">	buf.flip();</span><br><span class="line">	byte b[] &#x3D; new byte[bytesRead]; int i &#x3D; 0;</span><br><span class="line">	while (buf.hasRemaining()) &#123;</span><br><span class="line">	b[i] &#x3D; buf.get(); System.out.printf(&quot;%X&quot;, b[i]); </span><br><span class="line">	i++;</span><br><span class="line">    &#125;</span><br><span class="line">	String s &#x3D; new String(b); </span><br><span class="line">	System.out.println(&quot;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;||&quot; + s); </span><br><span class="line">	bytesRead &#x3D; sourceChannel.read(buf);</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>


<h3 id="二、FileChannel文件锁"><a href="#二、FileChannel文件锁" class="headerlink" title="二、FileChannel文件锁"></a>二、FileChannel文件锁</h3><p>  在通道中我们可以对文件或者部分文件进行上锁。上锁和我们了解的线程锁差不多，都是为 了保证数据的一致性。在文件通道 FileChannel 中可以对文件进行上锁，通过 FileLock 可以 对文件进行锁的释放。 文件加锁是建立在文件通道(FileChannel)之上的，套接字通道(SockeChannel)不考虑文 件加锁，因为它是不共享的。<br>它对文件加锁有两种方式:</p>
<ol>
<li>lock</li>
<li>tryLock     </li>
</ol>
<p>两种加锁方式默认都是对整个文件加锁，如果自己配置的话就可以控制加锁的文件范围: position 是加锁的开始位置，size 是加锁长度，shared 是用于控制该锁是共享的还是独占的。 </p>
<ul>
<li>lock 是阻塞式的，当有进程对锁进行读取时会等待锁的释放，在此期间它会一直等待;</li>
<li>tryLock 是非阻塞式的，它尝试获得锁，如果这个锁不能获得，那么它会立即返回。</li>
</ul>
<p>release 可以释放锁。<br>在一个进程中在锁没有释放之前是无法再次获得锁的<br>在 java 的 NIO 中，通道包下面有一个 FileLock 类，它主要是对文件锁工具的一个描述。在 上一小节中对文件的锁获取其实是 FileChannel 获取的(lock 与 trylock 是 FileChannel 的方 法)，它们返回一个 FileLock 对象。</p>
<p>这个类的核心方法有如下这些:<br>boolean isShared() :判断锁是否为共享类型<br>abstract boolean isValid() :判断锁是否有效<br>boolean overlaps():判断此锁定是否与给定的锁定区域重叠 long position():返回文件内锁定区域中第一个字节的位置。<br>abstract void release() :释放锁<br>long size() :返回锁定区域的大小，以字节为单位</p>
<p>在文件锁中有 3 种方式可以释放文件锁:</p>
<ol>
<li>锁类释放锁，调用 FileLock 的 release 方法 </li>
<li>通道类关闭通道，调用 FileChannel 的 close 方法</li>
<li>jvm 虚拟机会在特定情况释放锁。</li>
</ol>
<h3 id="锁类型-独占式和共享式"><a href="#锁类型-独占式和共享式" class="headerlink" title="锁类型(独占式和共享式)"></a>锁类型(独占式和共享式)</h3><p>我们先区分一下在文件锁中两种锁的区别:</p>
<ol>
<li>独占式的锁就想我们上面测试的那样，只要有一个进程获取了独占锁，那么别的进程只能等待。</li>
<li>共享锁在一个进程获取的情况下，别的 进程还是可以读取被锁定的文件，但是别的进程不能写只能读。</li>
</ol>
]]></content>
      <categories>
        <category>NIO 系列</category>
      </categories>
      <tags>
        <tag>java基础</tag>
        <tag>NIO</tag>
      </tags>
  </entry>
  <entry>
    <title>java NIO 相关(五) 分散(Scatter) 和聚集(Gather)</title>
    <url>/2020/05/17/java%20NIO%E7%9B%B8%E5%85%B3(%E4%BA%94)%20%E5%88%86%E6%95%A3(Scatter)%20%E5%92%8C%E8%81%9A%E9%9B%86(Gather)/</url>
    <content><![CDATA[<h3 id="分散-Scatter-和聚集-Gather"><a href="#分散-Scatter-和聚集-Gather" class="headerlink" title="分散(Scatter) 和聚集(Gather)"></a>分散(Scatter) 和聚集(Gather)</h3><p>分散读取(scattering reads) 是从channel中读取的数据“分散”到多个buffer中 </p>
<p><img src="https://dmr-blog.oss-cn-shanghai.aliyuncs.com/blog/image-d7dd945680e34da1b55f41c09e4c583f.png" alt="image.png"></p>
<span id="more"></span>
<p>注意:按照缓冲区的顺序,写入position 和limit 之间的数据到channel </p>
<ul>
<li>分散读取<br>将通道中的数据分散到多个缓冲区中 </li>
<li>聚集写入<br>将多个缓冲区中的数据聚集到通道中 </li>
</ul>
]]></content>
      <categories>
        <category>NIO 系列</category>
      </categories>
      <tags>
        <tag>java基础</tag>
        <tag>NIO</tag>
      </tags>
  </entry>
  <entry>
    <title>java NIO 相关(四) 通道 channel</title>
    <url>/2020/05/15/java%20NIO%E7%9B%B8%E5%85%B3(%E5%9B%9B)%20%E9%80%9A%E9%81%93%20channel/</url>
    <content><![CDATA[<h3 id="channel-介绍"><a href="#channel-介绍" class="headerlink" title="channel 介绍"></a>channel 介绍</h3><p>通道(channel) :由java.nio.channels包定义的,channel 表示IO源与目标打开的连接 。<br>Channel 类似于传统的流,只不过channel 本身不能直接访问数据,channel 只能与buffer进行交互</p>
<span id="more"></span>
<h4 id="一、通道-channel"><a href="#一、通道-channel" class="headerlink" title="一、通道(channel)"></a>一、通道(channel)</h4><p>用于源节点与目标节点的连接，在java nio中负责缓冲区数据的传输。channel本身不存储数据，因此需要配合缓冲区进行传输。 </p>
<ul>
<li>流与通道的区别<br>1、流是单向的，通道是双向的，可读可写。<br>2、流读写是阻塞的，通道可以异步读写。<br>3、流中的数据可以选择性的先读到缓存中，通道的数据总是要先读到一个缓存中，或从缓 存中写入</li>
</ul>
<h4 id="二、通道的主要实现类"><a href="#二、通道的主要实现类" class="headerlink" title="二、通道的主要实现类"></a>二、通道的主要实现类</h4><p>Java.nio.channels.Channel接口 </p>
<p>|–FileChannel </p>
<p>|–SocketChannel </p>
<p>|–ServerSocetChannel </p>
<p>|–DataramChannel </p>
<h4 id="三、获取通道"><a href="#三、获取通道" class="headerlink" title="三、获取通道"></a>三、获取通道</h4><p>JAVA针对支持通道的类提供了getChannel()方法 </p>
<p>本地IO </p>
<p>FileInputStream/FileOutputStream </p>
<p>RamdomAccessFile </p>
<p>网络IO </p>
<p>Socket </p>
<p>ServerSocket </p>
<p>DatagramSocket </p>
<p>在JDK1.7中的NIO.2 针对各个通道提供了静态方法open()  </p>
<p>在JDK1.7中的Files工具类的newByteChannel() </p>
<h4 id="四、非直接缓冲区使用channel的dome"><a href="#四、非直接缓冲区使用channel的dome" class="headerlink" title="四、非直接缓冲区使用channel的dome"></a>四、非直接缓冲区使用channel的dome</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public static void main(String[] args) &#123; </span><br><span class="line"></span><br><span class="line">        FileInputStream fis &#x3D; null; </span><br><span class="line"></span><br><span class="line">        FileOutputStream fos &#x3D; null; </span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F;nio 文件复制 </span><br><span class="line"></span><br><span class="line">        try &#123; </span><br><span class="line"></span><br><span class="line">            fis &#x3D; new FileInputStream(&quot;C:\\Users\\12113\\Desktop\\1.html&quot;); </span><br><span class="line"></span><br><span class="line">            fos &#x3D; new FileOutputStream(&quot;C:\\Users\\12113\\Desktop\\nio.html&quot;); </span><br><span class="line"></span><br><span class="line">            FileChannel fosChannel &#x3D; fos.getChannel(); </span><br><span class="line"></span><br><span class="line">            FileChannel fisChannel &#x3D; fis.getChannel(); </span><br><span class="line"></span><br><span class="line">            ByteBuffer buffer &#x3D;ByteBuffer.allocate(1024); </span><br><span class="line"></span><br><span class="line">            while (fisChannel.read(buffer)!&#x3D;-1)&#123; </span><br><span class="line"></span><br><span class="line">                buffer.flip(); &#x2F;&#x2F;写模式</span><br><span class="line"></span><br><span class="line">                fosChannel.write(buffer); </span><br><span class="line"></span><br><span class="line">                buffer.clear(); </span><br><span class="line"></span><br><span class="line">            &#125; </span><br><span class="line"></span><br><span class="line">        &#125; catch (FileNotFoundException e) &#123; </span><br><span class="line"></span><br><span class="line">        &#125; catch (IOException e) &#123; </span><br><span class="line"></span><br><span class="line">            e.printStackTrace(); </span><br><span class="line"></span><br><span class="line">        &#125; </span><br></pre></td></tr></table></figure>

<h4 id="五、直接缓冲区使用channel"><a href="#五、直接缓冲区使用channel" class="headerlink" title="五、直接缓冲区使用channel"></a>五、直接缓冲区使用channel</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public static void main(String[] args) throws IOException &#123; </span><br><span class="line"></span><br><span class="line">        FileChannel fileInChannel &#x3D; FileChannel.open(Paths.get(&quot;C:\\Users\\12113\\Desktop\\temp.txt&quot;), StandardOpenOption.READ); </span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">        FileChannel fileOutChannel &#x3D; FileChannel.open(Paths.get(&quot;C:\\Users\\12113\\Desktop\\nio3.txt&quot;), StandardOpenOption.WRITE, StandardOpenOption.READ, StandardOpenOption.CREATE_NEW); </span><br><span class="line">     MappedByteBuffer inByteBuffer &#x3D;  fileInChannel.map(MapMode.READ_ONLY, 0, fileInChannel.size()); </span><br><span class="line"></span><br><span class="line">        MappedByteBuffer outByteBuffer &#x3D;   fileOutChannel.map(MapMode.READ_WRITE, 0, fileInChannel.size()); </span><br><span class="line"></span><br><span class="line">        byte[] dest &#x3D;new byte[inByteBuffer.limit()]; </span><br><span class="line"></span><br><span class="line">        inByteBuffer.get(dest); </span><br><span class="line"></span><br><span class="line">        outByteBuffer.put(dest); </span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;通道之间传输 </span><br><span class="line"></span><br><span class="line">      fileInChannel.transferTo(0,fileInChannel.size(),fileOutChannel); </span><br><span class="line"></span><br><span class="line">    &#125; </span><br></pre></td></tr></table></figure>
<h3 id="六、channel-的数据传输"><a href="#六、channel-的数据传输" class="headerlink" title="六、channel 的数据传输"></a>六、channel 的数据传输</h3><p>transferTo() </p>
<p>transferFrom() </p>
<h3 id="七、图解channel"><a href="#七、图解channel" class="headerlink" title="七、图解channel"></a>七、图解channel</h3><p>Channel是一个独立的处理器，专门用于IO操作，附属于CPU。<br>在提出IO请求的时候，CPU不需要进行干预，也就提高了效率。<br><img src="https://dmr-blog.oss-cn-shanghai.aliyuncs.com/blog/image-b61c14c0c361492cabc9de32040154f4.png" alt="image.png"></p>
]]></content>
      <categories>
        <category>NIO 系列</category>
      </categories>
      <tags>
        <tag>java基础</tag>
        <tag>NIO</tag>
      </tags>
  </entry>
  <entry>
    <title>java NIO 相关(三) NIO 直接缓冲区和非直接缓冲区</title>
    <url>/2020/05/01/java%20NIO%E7%9B%B8%E5%85%B3(%E4%B8%89)%20NIO%20%E7%9B%B4%E6%8E%A5%E7%BC%93%E5%86%B2%E5%8C%BA%E5%92%8C%E9%9D%9E%E7%9B%B4%E6%8E%A5%E7%BC%93%E5%86%B2%E5%8C%BA/</url>
    <content><![CDATA[<h3 id="非直接缓冲区"><a href="#非直接缓冲区" class="headerlink" title="非直接缓冲区"></a>非直接缓冲区</h3><p>通过allocate() 方法分配缓冲区,将缓冲区建立在jvm的内存<br>直接与非直接缓冲区字节缓冲区要么是直接的，要么是非直接的·如果为直接字节缓冲区·则Java虐拟机会尽最大努力直接在此缓冲区上执行本机|/0操作·也就是说，在每次调用基础操作系统的一个本机1/0操作之前（或之后），虐拟机都会尽量避免将缓冲区的内容复制到中间缓冲区巾（或从中间缓冲区中复制内容）。</p>
<span id="more"></span>
<h3 id="直接缓冲区"><a href="#直接缓冲区" class="headerlink" title="直接缓冲区"></a>直接缓冲区</h3><p>通过allocateDirect() 方法分配直接缓冲区,将缓冲区建立在物理内存中，可以提高效率 </p>
<p>直接字节缓冲区可以通过调用此类的allocateDirect()工厂方法来创建·此方法返回的缓冲区透行分配和取消分配所需成本通常于非直接缓冲区·<br>直接缓冲区的内容可以驻留在常規的垃圾回收堆之外·因此．它们对应用程序的内存需求量造成的影响可能并不明显。所以，建议将直接缓冲区主要分配给那些易受基础系统的本机|/0操作影响的大型、持久的缓冲区·一情况下，最好舣在直接缓冲区能在程序性能方面帚来明显好处时分配它们</p>
<p>直接字节缓冲区还可以通过FileChanneI的map()方法将文件区域直接暌射到内存中来创建·该方法返回MappedByteBuffer·Java平台的实现有助于通过JNI从本机代码创建直接字节缓冲区·如果以上这些缓冲区中的某个缓冲区实蚪指的是不可访问的内存区域，则试图访问该区域不会更改该缓冲区的内容，并且将会在访问期间或鞘后的某时间导致出不定的异常·字节缓冲区是直接缓冲区还是非直接缓冲区可通过调用其isDirect()方法来确定．供此方法是为了能够在性能关键型代码中挾行显式缓冲区管理·</p>
<h3 id="图解直接缓冲区和非直接缓冲区"><a href="#图解直接缓冲区和非直接缓冲区" class="headerlink" title="图解直接缓冲区和非直接缓冲区"></a>图解直接缓冲区和非直接缓冲区</h3><p><img src="https://dmr-blog.oss-cn-shanghai.aliyuncs.com/blog/image-7e22439d787140f9befa9b7df1b6bb07.png" alt="image.png"></p>
<p><img src="https://dmr-blog.oss-cn-shanghai.aliyuncs.com/blog/image-d444ebf068de43d09e9caf772a44ae32.png" alt="image.png"></p>
<h3 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a>源码分析</h3><ul>
<li><p>直接缓冲区</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public static ByteBuffer allocate(int capacity) &#123; </span><br><span class="line"></span><br><span class="line">    if (capacity &lt; 0) </span><br><span class="line"></span><br><span class="line">         throw new IllegalArgumentException(); </span><br><span class="line"></span><br><span class="line">    return new HeapByteBuffer(capacity, capacity); </span><br><span class="line"></span><br><span class="line"> &#125; </span><br><span class="line"></span><br><span class="line">HeapByteBuffer(int cap, int lim) &#123;            &#x2F;&#x2F; package-private </span><br><span class="line"></span><br><span class="line">     super(-1, 0, lim, cap, new byte[cap], 0); </span><br><span class="line"></span><br><span class="line">     &#x2F;* </span><br><span class="line"></span><br><span class="line">       hb &#x3D; new byte[cap]; </span><br><span class="line"></span><br><span class="line">       offset &#x3D; 0; </span><br><span class="line"></span><br><span class="line">      *&#x2F; </span><br><span class="line"></span><br><span class="line"> &#125; </span><br><span class="line"></span><br><span class="line">可以看到直接在堆中创建空间也就是数组 </span><br></pre></td></tr></table></figure></li>
<li><p>非直接缓冲区<br>public static ByteBuffer allocateDirect(int capacity) { </p>
<pre><code>  return new DirectByteBuffer(capacity); 
</code></pre>
</li>
</ul>
<p>} </p>
<p>DirectByteBuffer(int cap) {                   // package-private </p>
<pre><code>    super(-1, 0, cap, cap); 

    boolean pa = VM.isDirectMemoryPageAligned(); 

    int ps = Bits.pageSize(); 

    long size = Math.max(1L, (long)cap + (pa ? ps : 0)); 

    Bits.reserveMemory(size, cap); 



    long base = 0; 

    try &#123; 

        base = unsafe.allocateMemory(size); 

    &#125; catch (OutOfMemoryError x) &#123; 

        Bits.unreserveMemory(size, cap); 

        throw x; 

    &#125; 

    unsafe.setMemory(base, size, (byte) 0); 

    if (pa &amp;&amp; (base % ps != 0)) &#123; 

        // Round up to page boundary 

        address = base + ps - (base &amp; (ps - 1)); 

    &#125; else &#123; 

        address = base; 

    &#125; 

    cleaner = Cleaner.create(this, new Deallocator(base, size, cap)); 

    att = null; 



&#125; 
</code></pre>
<p>可以看到是根据 </p>
<p>VM.isDirectMemoryPageAligned() 方法直接调用了内存分,让操作系统开辟缓存空间 </p>
<h3 id="DirectByteBuffer-堆外内存"><a href="#DirectByteBuffer-堆外内存" class="headerlink" title="DirectByteBuffer(堆外内存)"></a>DirectByteBuffer(堆外内存)</h3><p>DirectByteBuffer 继承自 MappedByteBuffer，它们都是使用的堆外内存，不受 JVM 堆大小的 限制，只是前者仅仅是分配内存，后者是将文件映射到内存中。<br>可以通过 ByteBuf.allocateDirect 方法获取</p>
<h4 id="堆外内存的特点-大对象-加快内存拷贝-减轻-GC-压力"><a href="#堆外内存的特点-大对象-加快内存拷贝-减轻-GC-压力" class="headerlink" title="堆外内存的特点(大对象;加快内存拷贝;减轻 GC 压力)"></a>堆外内存的特点(大对象;加快内存拷贝;减轻 GC 压力)</h4><ul>
<li>对于大内存有良好的伸缩性(支持分配大块内存)</li>
<li>对垃圾回收停顿的改善可以明显感觉到(堆外内存，减少 GC 对堆内存回收的压力)</li>
<li>在进程间可以共享，减少虚拟机间的复制，加快复制速度(减少堆内内存拷贝到堆<br>外内存的过程)</li>
<li>还可以使用 池+堆外内存 的组合方式，来对生命周期较短，但涉及到 I/O 操作的对象进行堆外内存的再使用。( Netty 中就使用了该方式 )</li>
</ul>
<h4 id="堆外内存的一些问题"><a href="#堆外内存的一些问题" class="headerlink" title="堆外内存的一些问题"></a>堆外内存的一些问题</h4><ol>
<li>堆外内存回收问题(不手工回收会导致内存溢出，手工回收就失去了 Java 的优势);</li>
<li>数据结构变得有些别扭。要么就是需要一个简单的数据结构以便于直接映射到堆外内存， 要么就使用复杂的数据结构并序列化及反序列化到内存中。很明显使用序列化的话会比较头 疼且存在性能瓶颈。使用序列化比使用堆对象的性能还差。  </li>
</ol>
<h4 id="堆外内存的释放"><a href="#堆外内存的释放" class="headerlink" title="堆外内存的释放"></a>堆外内存的释放</h4><p>  java.nio.DirectByteBuffer 对象在创建过程中会先通过 Unsafe 接口直接通过 os::malloc 来分配 内存，然后将内存的起始地址和大小存到 java.nio.DirectByteBuffer 对象里，这样就可以直接 操作这些内存。这些内存只有在 DirectByteBuffer 回收掉之后才有机会被回收，因此如果这 些对象大部分都移到了 old，但是一直没有触发 CMS GC 或者 Full GC，那么悲剧将会发生， 因为你的物理内存被他们耗尽了，因此为了避免这种悲剧的发生，通过 -XX:MaxDirectMemorySize 来指定最大的堆外内存大小，当使用达到了阈值的时候将调用 System.gc 来做一次 full gc，以此来回收掉没有被使用的堆外内存。<br> GC 方式:<br>存在于堆内的 DirectByteBuffer 对象很小，只存着基地址和大小等几个属性，和一个 Cleaner， 但它代表着后面所分配的一大段内存，是所谓的冰山对象。通过前面说的 Cleaner，堆内的 DirectByteBuffer 对象被 GC 时，它背后的堆外内存也会被回收。<br>当新生代满了，就会发生 minor gc;如果此时对象还没失效，就不会被回收;撑过几次 minorgc 后，对象被迁移到老生代;当老生代也满了，就会发生 full gc。 这里可以看到一种尴尬的情况，因为 DirectByteBuffer 本身的个头很小，只要熬过了 minor gc， 即使已经失效了也能在老生代里舒服的呆着，不容易把老生代撑爆触发 full gc，如果没有别 的大块头进入老生代触发 full gc，就一直在那耗着，占着一大片堆外内存不释放。<br>这时，就只能靠前面提到的申请额度超限时触发的 System.gc()来救场了。但这道最后的保 险其实也不很好，首先它会中断整个进程，然后它让当前线程睡了整整一百毫秒，而且如果 gc 没在一百毫秒内完成，它仍然会无情的抛出 OOM 异常。<br>那为什么 System.gc()会释放 DirectByteBuffer 呢?<br>每个 DirectByteBuffer 关联着其对应的 Cleaner，Cleaner 是 PhantomReference 的子类，虚 引用主要被用来跟踪对象被垃圾回收的状态，通过查看 ReferenceQueue 中是否包含对象所 对应的虚引用来判断它是否即将被垃圾回收。<br>当GC时发现DirectByteBuffer除了PhantomReference外已不可达，就会把它放进 Reference 类 pending list 静态变量里。然后另有一条 ReferenceHandler 线程，名字叫 “Reference Handler”的，关注着这个 pending list，如果看到有对象类型是 Cleaner，就会执行它的 clean()， 其他类型就放入应用构造 Reference 时传入的 ReferenceQueue 中，这样应用的代码可以从 Queue 里拖出这些理论上已死的对象，做爱做的事情——这是一种比 finalizer 更轻量更好的 机制。<br>手工方式:<br>如果想立即释放掉一个 MappedByteBuffer/DirectByteBuffer，因为 JDK 没有提供公开 API， 只能使用反射的方法去 unmap;<br>或者使用 Cleaner 的 clean 方法。</p>
]]></content>
      <categories>
        <category>NIO 系列</category>
      </categories>
      <tags>
        <tag>java基础</tag>
        <tag>NIO</tag>
      </tags>
  </entry>
  <entry>
    <title>java NIO 相关(二) 缓冲区buffer的数据存取</title>
    <url>/2020/04/13/java%20NIO%E7%9B%B8%E5%85%B3(%E4%BA%8C)%20%E7%BC%93%E5%86%B2%E5%8C%BAbuffer%E7%9A%84%E6%95%B0%E6%8D%AE%E5%AD%98%E5%8F%96/</url>
    <content><![CDATA[<h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><p> java nio 是jdk1.4引入的,其中包含 selector,channel,buffer 其中buffer是用来提高效率的。nio中操作数据,都是直接操作buffer对象<br> <span id="more"></span></p>
<h3 id="buffer的类型"><a href="#buffer的类型" class="headerlink" title="buffer的类型"></a>buffer的类型</h3><ul>
<li>ByteBuffer</li>
<li>CharBuffer </li>
<li>ShortBuffer </li>
<li>IntBuffer </li>
<li>LongBuffer </li>
<li>FloatBuffer </li>
<li>DoubleBuffer   </li>
</ul>
<p>java基本类型除了boolean外都有对应的buffer的对象，都是使用allocate()方法创建对应的buffer对象</p>
<h3 id="Buffer-的相关属性"><a href="#Buffer-的相关属性" class="headerlink" title="Buffer 的相关属性"></a>Buffer 的相关属性</h3><ul>
<li>capacity 容量<br>用来定义buffer的容量，在buffer初始化的时候设置,不可被修改</li>
<li>limit 界限</li>
<li>buffer的上限位置,limit &lt;= capacity</li>
<li>pasition 位置</li>
<li>读写buffer的时候,下一个写或者读的位置 pasition小于 limit</li>
<li>mark 标记位置</li>
<li>使用mark()方法标记的位置,当调用reset()方法时,将pasition指向mark的位置</li>
</ul>
<h3 id="buffer-初始化"><a href="#buffer-初始化" class="headerlink" title="buffer 初始化"></a>buffer 初始化</h3><p> buffer 初始化调用 allocate()方法创建,下面看一下源码</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public static ByteBuffer allocate(int capacity) &#123;</span><br><span class="line">       if (capacity &lt; 0)</span><br><span class="line">           throw new IllegalArgumentException();</span><br><span class="line">       return new HeapByteBuffer(capacity, capacity);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看到 使用 new HeapByteBuffer(capacity, capacity); 在jvm堆中创建一个buffer对象</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Buffer(int mark, int pos, int lim, int cap) &#123;</span><br><span class="line">        if (cap &lt; 0)</span><br><span class="line">            throw new IllegalArgumentException(&quot;Negative capacity: &quot; + cap);</span><br><span class="line">        this.capacity &#x3D; cap;</span><br><span class="line">        limit(lim);</span><br><span class="line">        position(pos);</span><br><span class="line">        if (mark &gt;&#x3D; 0) &#123;</span><br><span class="line">            if (mark &gt; pos)</span><br><span class="line">                throw new IllegalArgumentException(&quot;mark &gt; position: (&quot;+ mark + &quot; &gt; &quot; + pos +&quot;)&quot;);</span><br><span class="line">            this.mark &#x3D; mark;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>当初始化Bytebuffer后实际的buffer对象的相关属性情况如下。</p>
<p><img src="https://dmr-blog.oss-cn-shanghai.aliyuncs.com/blog/image-9547fa6a4cc94749b8f60b2e7126ee82.png" alt="image.png"></p>
<h3 id="Buffer的核心方法"><a href="#Buffer的核心方法" class="headerlink" title="Buffer的核心方法"></a>Buffer的核心方法</h3><ul>
<li>get()<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public byte get() &#123;</span><br><span class="line">    return hb[ix(nextGetIndex())];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">final int nextGetIndex() &#123;</span><br><span class="line">    if (position &gt;&#x3D; limit)</span><br><span class="line">        throw new BufferUnderflowException();</span><br><span class="line">    return position++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>put()<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public ByteBuffer put(byte x) &#123;</span><br><span class="line">    hb[ix(nextPutIndex())] &#x3D; x;</span><br><span class="line">    return this;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">final int nextPutIndex() &#123;</span><br><span class="line">    if (position &gt;&#x3D; limit)</span><br><span class="line">        throw new BufferOverflowException();</span><br><span class="line">    return position++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
比如put a,b,c,d 到buffer中实际的存储情况是这样的<br><img src="https://dmr-blog.oss-cn-shanghai.aliyuncs.com/blog/image-89fc5cc79c294db8989fa7d3aff05af9.png" alt="image.png"><br>每次put的时候position 都指向后一位</li>
<li>flip()<br>上图我们将a,b,c,d 加入到buffer后。当我们调用get()方法的时候是获取不到数据的,因为position是5调用get方法获取不到数据。<br> 所以我们想获取数据,需要将position重新设置为0<br> 查看get()源码,我们发现position &gt;= limit才会抛出异常。所以我们还需要设置limit到5,需要两部操作。而flip()方法是将上面两个操作和成一个方法。执行的结果如下<br><img src="https://dmr-blog.oss-cn-shanghai.aliyuncs.com/blog/image-6ffc3b8c1c6343a3905826f1f9b5a791.png" alt="image.png"></li>
<li>Rewind()<br>我们指向将position恢复到0,不影响limit,可以调用这个方法。</li>
<li>Clear()<br>调用clear方法,会将position设置到0,limit设置到capatity<br>在数组中真是的数据是没有被删除的。后续的put操作会覆盖原来的数据。</li>
<li>Mark()<br>标记,表示记录到当前position 的位置可以通过reset()恢复到mark()标记位置 </li>
<li>hasremaining()<br>判断缓冲区中是否还有剩余数据 </li>
<li>Remaining()<br>获取缓冲区还可以操作的数据 </li>
</ul>
]]></content>
      <categories>
        <category>NIO 系列</category>
      </categories>
      <tags>
        <tag>java基础</tag>
        <tag>NIO</tag>
      </tags>
  </entry>
  <entry>
    <title>java NIO 相关(一) NIO介绍</title>
    <url>/2020/03/25/java%20NIO%20%E7%9B%B8%E5%85%B3(%E4%B8%80)%20NIO%E4%BB%8B%E7%BB%8D/</url>
    <content><![CDATA[<h3 id="Java-NIO简介"><a href="#Java-NIO简介" class="headerlink" title="Java NIO简介"></a>Java NIO简介</h3><p style="text-indent:2em">
Java nio (new io) 是从java 1.4 版本开始引入有的一个新的IO API 可以替代标准的java io API.</p>
<p style="text-indent:2em">
NIO 和原来的io有同样的作用和目的,但是使用方式完全不通，NIO支持面向缓存区的基于通道的IO操作,NIO将以更加高效的方式进行文件的读写操作。 
</p>
<span id="more"></span>
|io|nio|
|-------|-------|
|面向流|面向缓冲区|
|阻塞io|同步非阻塞io|
|无|selector选择器
### 通道和缓冲区
Java nio 系统的核心在于：通道(channel) 和缓冲区(buffer) 通道表示打开到IO设备(例如:文件、套接字)的连接,若需要使用NIO,需要获取用于连接IO的通道以及用于容纳数据的缓冲区,然后操作缓冲区,对数据进行处理。
 1. 先建立通道
 2. 创建缓冲区
 3. 操作缓冲区
### io 输入流的读取数据逻辑
1. io读取数据
 - 打开一个io流
 - 循环
 - 读取数据
 - 关闭io流
2. io写入数据
 - 打开一个io流
 - 循环
 - 写入取数据
 - 关闭io流
### 相关概念
- Java.io 中最为核心的一个概念就是流，面向流的编程，一个流要么是输入流要么是输出流，不可能同时即是输出流又是输出流 

<ul>
<li><p>Java.nio中拥有3个概念 selector channel 和 buffer 在java.nio中我们是面向块(blocl)或是缓冲区(buffer)编程的 buffer本事就是一个堆存区域地址是线上他就是一个数组，数据的读和写都是通过buffer来实现的 </p>
</li>
<li><p>除了数组之外，buffer还提供了对于数据的结构化访问方式，并且可以追踪到系统的读写过程 </p>
</li>
<li><p>java中的8种原生数据类型都有各自对应的buffer类型 如intbuffer longbuffer bytebuffer charbuffer  boolean除外</p>
</li>
<li><p>Channel 指的是可以向其写入数据或是从中读取数据对象，它类似于 java中的stream </p>
</li>
<li><p>所有数据的读写都是通过buffer来进行的，永远不过出现直接向channel写入数据的情况，或是直接从channel读取数据的情况 </p>
</li>
<li><p>与stream不同的是 channel是双向的 一个流只可能是inputstream 或是outputstream,channel打开后可以进行读取写入或是读写 </p>
</li>
<li><p>由于channel是双向的因此他能更好的放映出操作系统的真实情况，在linux系统中底层操作系统的通道就是双向的     </p>
<h3 id="java-io-和-nio的区别"><a href="#java-io-和-nio的区别" class="headerlink" title="java io 和 nio的区别"></a>java io 和 nio的区别</h3><p><img src="https://dmr-blog.oss-cn-shanghai.aliyuncs.com/blog/image-9b532762da67441e9d0ede2df1f1df40.png" alt="image.png"><br><img src="https://dmr-blog.oss-cn-shanghai.aliyuncs.com/blog/image-2466c17e0918461991e0f5312aa97c6b.png" alt="image.png"></p>
</li>
</ul>
]]></content>
      <categories>
        <category>NIO 系列</category>
      </categories>
      <tags>
        <tag>java基础</tag>
        <tag>NIO</tag>
      </tags>
  </entry>
  <entry>
    <title>java IO相关(二) BIO NIO AIO 介绍</title>
    <url>/2020/03/20/%20java%20IO%E7%9B%B8%E5%85%B3(%E4%BA%8C)%20BIO%20NIO%20AIO%20%E4%BB%8B%E7%BB%8D/</url>
    <content><![CDATA[<h3 id="BIO"><a href="#BIO" class="headerlink" title="BIO"></a>BIO</h3><p>bio 同步阻塞,每一个请求连接都由一个线程来处理</p>
<h3 id="NIO"><a href="#NIO" class="headerlink" title="NIO"></a>NIO</h3><p>nio 同步非阻塞,多路复用器轮询客户端的请求，每个客户端的 IO 请求会对应服务器的 一个线程</p>
<span id="more"></span>
<h3 id="AIO"><a href="#AIO" class="headerlink" title="AIO"></a>AIO</h3><p>aio 异步非阻塞,客户端的io请求都是由os来处理,os处理完成后再通知服务器启动线程处理 （需要操作系统支持）</p>
<ol>
<li>进程向操作系统请求数据</li>
<li>操作系统把外部数据加载到内核的缓冲区中</li>
<li>操作系统把内核的缓冲区拷贝到进程的缓冲区</li>
<li>进程获得数据完成自己的功能</li>
</ol>
<p>Java NIO 属于同步非阻塞 IO，即 IO 多路复用，单个线程可以支持多个 IO 即询问时从 IO 没有完毕时直接阻塞，变成了立即返回一个是否完成 IO 的信号。<br>异步 IO 就是指 AIO，AIO 需要操作系统支持。</p>
]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>java基础</tag>
        <tag>IO</tag>
        <tag>NIO</tag>
      </tags>
  </entry>
  <entry>
    <title>java IO相关(一) unix的五种模型</title>
    <url>/2020/03/19/%20java%20IO%E7%9B%B8%E5%85%B3(%E4%B8%80)%20unix%E7%9A%84%E4%BA%94%E7%A7%8D%E6%A8%A1%E5%9E%8B/</url>
    <content><![CDATA[<h2 id="Uinx-IO-模型"><a href="#Uinx-IO-模型" class="headerlink" title="Uinx IO 模型"></a>Uinx IO 模型</h2><p> unix 的io 模型分为以下5类</p>
<h3 id="阻塞io"><a href="#阻塞io" class="headerlink" title="阻塞io"></a>阻塞io</h3><p> 当用户发起io请求后,等待数据,程序将数据从内核复制到程序缓冲区中,整个操作都是阻塞状态。<br><img src="https://dmr-blog.oss-cn-shanghai.aliyuncs.com/blog/io1-1b12b48aee254809bd650ffc4638195c.png" alt="阻塞io"></p>
<span id="more"></span>
<h3 id="非阻塞io"><a href="#非阻塞io" class="headerlink" title="非阻塞io"></a>非阻塞io</h3><p> 当用户发起请求后,不等待数据,而是返回一个数据未准备完成的标志。<br> 操作系统内核将准备要操作的数据,这个过程中程序会轮训的请求操作,直到操作系统将数据准备好。当程序轮训到系统内核响应数据准备好了之后,程序再将数据复制到程序自身的缓冲区<br><img src="https://dmr-blog.oss-cn-shanghai.aliyuncs.com/blog/io2-a6ec6899ab26428aa95bb80299e05774.png" alt="io2.png"></p>
<h3 id="io复用模型"><a href="#io复用模型" class="headerlink" title="io复用模型"></a>io复用模型</h3><p> 我们常用select和poll函数使用了io复用模型。<br> 当用户调用select函数的时候会阻塞,select函数会系统调用操作内核进行数据报的准备工作。当数据报准备完成后,程序直接复制数据包的内容到程序缓冲区中,io复用现在看来和阻塞io没有什么区别。但是当用户比较多的时候优势就展现出来了，假设有100个用户阻塞io会阻塞100个进程处理io.<br>如果是io复用模型,则用1个线程去管理这100个io请求。<br><img src="https://dmr-blog.oss-cn-shanghai.aliyuncs.com/blog/io3-5be9c90b5af44e739cf8f0c744a1e72c.png" alt="io3.png"><br> <img src="https://dmr-blog.oss-cn-shanghai.aliyuncs.com/blog/Xnip2020-03-14_00-36-30-a59ced60a0aa466691f3f2ef42442a4c.jpg" alt="Xnip20200314_003630.jpg"></p>
<h3 id="信号驱动io"><a href="#信号驱动io" class="headerlink" title="信号驱动io"></a>信号驱动io</h3><p>我们可以使用信号.当用户发起io请求后,使程序接受操作系统的信号通知。<br>不等待数据。此时操作系统进行数据报的准备，当数据报准备完成之后会以信号的方式通知程序。程序收到数据准备完成的信号通知后，在将数据复制到程序缓冲区中。<br><img src="https://dmr-blog.oss-cn-shanghai.aliyuncs.com/blog/io4-1502c54ca1fb46e7ac155f3db3620c78.png" alt="io4.png"></p>
<h3 id="异步io"><a href="#异步io" class="headerlink" title="异步io"></a>异步io</h3><p>当用户发起请求后不等待数据,操作系统内核直接将数据复制到程序的缓存区中，等到复制完成之后在通知程序操作成功。<br><img src="https://dmr-blog.oss-cn-shanghai.aliyuncs.com/blog/io5-a35468fd1fe94b7a8d90b07ecaaa0ca9.png" alt="io5.png"></p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>前四种io模型都属于同步io，其中的第二阶段相同，都属于数据报准备完成后，操作系统内核将数据复制到程序的缓存区中。  </p>
<ol>
<li>阻塞io则在数据准备和数据准备完成一直处于阻塞中</li>
<li>非阻塞io则是轮训的方式一直请求操作系统内核数据报是否准备完成</li>
<li>多路复用io则是发起io请求后,调用select。select单线程来判断那个io请求的数据报是否准备好。然后系统直接调用。</li>
<li>信号io则是 操作系统内核在数据报准备好的时候以信号的方式通知程序</li>
<li>异步io全程都是操作系统进行io处理，在处理io结束后通知程序</li>
<li>异步非异步的区别是io操作过程是否由操作系统处理。</li>
<li>阻塞非阻塞是io操作，操作系统是否返回一个标志告知io操作是否完成</li>
</ol>
<h3 id="相关博客"><a href="#相关博客" class="headerlink" title="相关博客"></a>相关博客</h3><p><a href="https://www.cnblogs.com/Lynn-Zhang/p/5711849.html">Unix下 五种 I/O模型</a></p>
<p><a href="https://blog.csdn.net/lihao21/article/details/51620374">图解UNIX的I/O模型</a></p>
]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>java基础</tag>
        <tag>IO</tag>
        <tag>NIO</tag>
      </tags>
  </entry>
  <entry>
    <title>java 基础知识点整理(三)</title>
    <url>/2020/03/11/%20java%20%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E7%82%B9%E6%95%B4%E7%90%86(%E4%B8%89)/</url>
    <content><![CDATA[<h3 id="1-枚举的jdk实现"><a href="#1-枚举的jdk实现" class="headerlink" title="(1) 枚举的jdk实现"></a>(1) 枚举的jdk实现</h3><p> 下面是枚举代码  </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public enum Labels0 &#123;</span><br><span class="line"></span><br><span class="line"> ENVIRONMENT(&quot;环保&quot;), TRAFFIC(&quot;交通&quot;), PHONE(&quot;手机&quot;); private </span><br><span class="line"></span><br><span class="line"> String name;</span><br><span class="line"></span><br><span class="line"> private Labels0(String name) &#123; this.name &#x3D; name;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">public String getName() &#123; </span><br><span class="line">    return name;</span><br><span class="line">   &#125; </span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<span id="more"></span>
<p>在编译后生成的字节码如下:<br><img src="https://dmr-blog.oss-cn-shanghai.aliyuncs.com/blog/Xnip2020-03-08_21-47-37-d207e2f4043a439ead86e11865270cd3.jpg" alt="Xnip20200308_214737.jpg"><br>可以看到枚举被编译后就是一个类，被编辑为final并且继承Enum<br>里面的枚举都是static finak的常量，静态的所以是单例的<br>重点：<br>++枚举类型没有可以访问的构造器，是真正的 final;是实例受控的，它们是单例的泛型化; 本质上是单元素的枚举;提供了编译时的类型安全。 单元素的枚举是实现单例的最佳方法!++</p>
<h3 id="2-jdk序列化"><a href="#2-jdk序列化" class="headerlink" title="(2) jdk序列化"></a>(2) jdk序列化</h3><p> 定义：将实现Serializable接口的对象转成一个字节数组,并且可以讲字节数组转换为对象</p>
<ol>
<li>实现序列化</li>
</ol>
<ul>
<li>实现Serializable接口</li>
<li>该接口只是一个可序列化的标志并没包含实际的属性和方法</li>
<li>如果不在该方法中添加readObject 和 writeObject 则采取默认的序列化机制，如果添加了这两个方法还想执行默认的序列化机制 则需要分别调用 defaultReadObject()和defaultWriteObject()方法</li>
<li>为了保障安全性可以使用transient关键字修饰不必序列化的属性因为在序列化的过程中private的属性也会被序列化</li>
<li>实现ExternalSerializable接口 可以对要求序列化的内容进行控制，控制那些属性能被序列化，那些不能被序列化</li>
</ul>
<ol start="2">
<li>反序列化</li>
</ol>
<ul>
<li>实现Serializable接口接口反序列化,无需调用构造方法，完全处于字节</li>
<li>实现ExternalSerializable接口方法在反序列化的时候调用构造方法</li>
</ul>
<ol start="3">
<li>注意事项</li>
</ol>
<ul>
<li>被static 修饰的对象不会被序列化</li>
<li>对象的类名 属性都会被序列化，方法不会被序列化</li>
<li>保证序列化对象对象所在类的属性也是可以被序列化的</li>
</ul>
<ol start="4">
<li>ObjectOutputStream 是专门用来输出对象的输出流;<br>ObjectOutputStream 将 Java 对象写入 OutputStream。可以使用 ObjectInputStream 读取 (重构)对象。</li>
<li>serialVersionUID<br>用来判断序列化的版本号的，如果反序列化的时候如果版本号不一致则会抛异常  </li>
</ol>
<h3 id="3-ERROR-和-Exception"><a href="#3-ERROR-和-Exception" class="headerlink" title="(3)ERROR 和 Exception"></a>(3)ERROR 和 Exception</h3><ol>
<li>error 是程序无法处理的错误，是有jvm虚拟机器抛出的异常如。outofmemorayerror,虚拟机将发生这种异常的线程直接终止</li>
<li>exception 是可以程序可以处理的异常，是程序主动抛出的异常。<br>异常氛围检查时异常和非检查异常，检查异常需要try cache 非检查异常无需try cache</li>
</ol>
<h3 id="4-常见的RuntimeException"><a href="#4-常见的RuntimeException" class="headerlink" title="(4)常见的RuntimeException"></a>(4)常见的RuntimeException</h3><ol>
<li>NullPointerExcepiton  空指针</li>
<li>IllegalArgumentExcepiton  参数无效</li>
<li>ArraysOutOfBoundsExcepiton 数组越界</li>
<li>ClassCaseException 类型转换异常</li>
<li>NumberFormatException 数字转换异常  </li>
</ol>
<h3 id="5-泛型擦除"><a href="#5-泛型擦除" class="headerlink" title="(5)泛型擦除"></a>(5)泛型擦除</h3><p> 编辑器生成的字节码是不包含泛型信息的,编译过程中会擦除泛型。限定类型会指向限定类型，非限定类型则指向object</p>
]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>java基础</tag>
        <tag>源码</tag>
      </tags>
  </entry>
  <entry>
    <title>java 基础知识点整理(二)</title>
    <url>/2020/03/07/%20java%20%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E7%82%B9%E6%95%B4%E7%90%86(%E4%BA%8C)/</url>
    <content><![CDATA[<h3 id="1-抽象类和接口"><a href="#1-抽象类和接口" class="headerlink" title="(1) 抽象类和接口"></a>(1) 抽象类和接口</h3><p>区别：</p>
<ol>
<li>抽象类可以有的方法可以有普通方法，接口的方法全都是抽象方法</li>
<li>抽象类可以用普通成员变量,接口中只有常量也就是，static final的</li>
<li>抽象类是单继承,接口可以多继承  <span id="more"></span>
<h3 id="2-面向对象的三大特性"><a href="#2-面向对象的三大特性" class="headerlink" title="(2) 面向对象的三大特性"></a>(2) 面向对象的三大特性</h3></li>
<li>封装<br> 将对象属性封装起来，只提供相关方法保障对象安全性,隐藏细节性。</li>
<li>继承<br>代码复用,增加扩展性</li>
<li>多态<pre><code>允许对象的不通子类对一个方法作出多种实现。
多态的三个条件，继承,子类重写夫类的方法,父类的引用只想子类的实现
</code></pre>
</li>
</ol>
<h3 id="3-重写和重载"><a href="#3-重写和重载" class="headerlink" title="(3) 重写和重载"></a>(3) 重写和重载</h3><ol>
<li>重写<br> 子类重写夫类的方法,根据子类的类型调用具体的方法</li>
<li>重载<br>在同类下，方法名相同，参数数量不同  </li>
</ol>
<h3 id="4-ThreadLocal-线程局部变量"><a href="#4-ThreadLocal-线程局部变量" class="headerlink" title="(4) ThreadLocal(线程局部变量)"></a>(4) ThreadLocal(线程局部变量)</h3><p>   线程之间共享变量是有风险的,如果想每一个线程使用自己的变量可以使用ThreadLocal来实现<br>   ThreadLocal 实际上是使用 ThreadLocalMap 来实现的 key 存储的是ThreadLocal,value为当前线程存储的变量<br>    因为线程都有一个ThreadLocalMap 的属性。<br>    1. set方法<br>        (1) 获取当前线程<br>    (2) 从当前线程获取ThreadLocalMap对象<br>    (3) 把ThreadLoacl对象作为key value为要存储的值<br>    (4) 如果获取当前线程ThreadLocalMap 为空 则创建ThreadLocalMap<br>   <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"> public void set(T value) &#123;</span><br><span class="line">    Thread t &#x3D; Thread.currentThread();</span><br><span class="line">    ThreadLocalMap map &#x3D; getMap(t);</span><br><span class="line">    if (map !&#x3D; null)</span><br><span class="line">        map.set(this, value);</span><br><span class="line">    else</span><br><span class="line">        createMap(t, value);</span><br><span class="line">&#125;		 </span><br></pre></td></tr></table></figure><br>   2. get方法<br>       (1) 获取当前线程<br>    (2) 从当前线程获取ThreadLocalMap,将当前的ThreadLocal作为key 获取对应的value值</p>
<pre><code> public T get() &#123;
    Thread t = Thread.currentThread();
    ThreadLocalMap map = getMap(t);
    if (map != null) &#123;
        ThreadLocalMap.Entry e = map.getEntry(this);
        if (e != null) &#123;
            @SuppressWarnings(&quot;unchecked&quot;)
            T result = (T)e.value;
            return result;
        &#125;
    &#125;
    return setInitialValue();
&#125;
</code></pre>
<h3 id="5-ThreadLocalMap的key为什么是弱引用？"><a href="#5-ThreadLocalMap的key为什么是弱引用？" class="headerlink" title="(5) ThreadLocalMap的key为什么是弱引用？"></a>(5) ThreadLocalMap的key为什么是弱引用？</h3><p>   如果不是弱引用则ThreadLocalMap无法释放内存<br>    1. 如果是普通的Map用来存储，theadlocal一直与线程保持强引用的关系<br>    2. 会导致gc时如果线程不结束，则无法进行垃圾回收(gc 垃圾回收是可达性判断,强引用的关系是无法进行gc)的<br>    3. ThreadLocalMap 的key 为弱引用 继承了Weakreference来实现的<br>    4. ThreadLocalMap 为垃圾回收实现了便利</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;   ThreadLocalMap的key</span><br><span class="line"> static class Entry extends WeakReference&lt;ThreadLocal&lt;?&gt;&gt; &#123;</span><br><span class="line">     &#x2F;** The value associated with this ThreadLocal. *&#x2F;</span><br><span class="line">          Object value;</span><br><span class="line">          Entry(ThreadLocal&lt;?&gt; k, Object v) &#123;</span><br><span class="line">              super(k);</span><br><span class="line">              value &#x3D; v;</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br></pre></td></tr></table></figure>
<h3 id="6-ThreadLocal-内存泄漏"><a href="#6-ThreadLocal-内存泄漏" class="headerlink" title="(6) ThreadLocal 内存泄漏"></a>(6) ThreadLocal 内存泄漏</h3><p>  只有调用ThreadLocal的get set remove方法才会采取措施来进行处理 ThreadLocal对应的value，<br>  如果在局部定义ThreadLocal但是没有显示的调用remove方法怎会产生内存泄漏。<br>  因为在 set或get方法的时候会将key为null的对象去除这样，对应的value没有gc root了,则会被gc回收<br>  jdk建议将ThreadLocal定义为 static final的 这样 它的声明周期更长,由于一直都存在强引用，这样就能保证在任何时候都能获取到对应 Entry的value值，然后remove它，防止内存泄露。</p>
<h3 id="7-Comparable-和-Comparator的区别"><a href="#7-Comparable-和-Comparator的区别" class="headerlink" title="(7) Comparable 和 Comparator的区别"></a>(7) Comparable 和 Comparator的区别</h3><ol>
<li> Comparable 是接口 Coparator是类</li>
<li>需要排序的类都实现了Comparable 并且重写了 compare方法<br>this.==obj   结果0<br>this.&gt; obj   结果正数<br>this.&lt; obj   结果负数</li>
<li>Comparator 可以传入到排序集合工具类的sort方法进行控制<h3 id="8-继承"><a href="#8-继承" class="headerlink" title="(8) 继承"></a>(8) 继承</h3></li>
<li>子类继承父类所有成员变量 (private 成员只有拥有权没有访问权)</li>
<li>子类可以直接使用父类的非private的成员隐式使用则在编译期间自动加上super关键字</li>
</ol>
<h3 id="9-fianl-相关"><a href="#9-fianl-相关" class="headerlink" title="(9) fianl 相关"></a>(9) fianl 相关</h3><ol>
<li>final 修饰类 ,类不能被继承 如String </li>
<li>final 修饰方法,方法不能被重写,重载</li>
<li>final 修饰属性,属性不可变 常量  </li>
</ol>
<h3 id="10-try-cache-finaly-return"><a href="#10-try-cache-finaly-return" class="headerlink" title="(10) try{}cache{}finaly return"></a>(10) try{}cache{}finaly return</h3><ol>
<li>在 try {} 中return 会执行finaly的逻辑</li>
<li>在 try {} 中return 并且 finaly 也有retrun 返回的是try {} 中return 的值,retrun的时候是直接将retrun的值放到临时保存到局部变量中,等到finaly执行结束后会直接从该位置的值直接返回</li>
<li>无论执行return break continue 都会执行 finaly的内容，除非调System.exist()</li>
</ol>
<h3 id="11-switch字符串的实现"><a href="#11-switch字符串的实现" class="headerlink" title="(11) switch字符串的实现"></a>(11) switch字符串的实现</h3><p>switch的字符串的实现原理是int,在编译后switch的字符串会变为hashcode的值</p>
]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>java基础</tag>
      </tags>
  </entry>
  <entry>
    <title>java 基础知识点整理(一)</title>
    <url>/2020/03/04/%20java%20%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E7%82%B9%E6%95%B4%E7%90%86(%E4%B8%80)/</url>
    <content><![CDATA[<h3 id="（1）JDK-amp-JRE-amp-JVM-的关系"><a href="#（1）JDK-amp-JRE-amp-JVM-的关系" class="headerlink" title="（1）JDK &amp; JRE &amp; JVM 的关系"></a>（1）JDK &amp; JRE &amp; JVM 的关系</h3><ol>
<li>JDK<br>JDK包含jre、java开发工具、java核心类库</li>
<li>JRE<br>jre是运行java程序的环境，包含java核心类库,和jvn的标准实现</li>
<li>JVM<br>是java虚拟机，实现java跨平台最核心的部分  <span id="more"></span>
<h3 id="（2）跨平台"><a href="#（2）跨平台" class="headerlink" title="（2）跨平台"></a>（2）跨平台</h3></li>
</ol>
<p>因为jvm运行的是java编译后的字节码文件,因为jvm可以在多个平台安装,所以字节码文件就可以在多个平台的jvm上面运行.从而实现一次编译到处运行</p>
<h3 id="（3）基础数据类型"><a href="#（3）基础数据类型" class="headerlink" title="（3）基础数据类型"></a>（3）基础数据类型</h3><p> 整型：    byte、short、int、long<br> 浮点型：double、float<br> 逻辑型：boolean<br> 字符型：char<br> 长度<br> byte(1) 2的-7次方 到2的7次方-1<br> short(2) 2的-15次方 到 2的 15 次方-1<br> int(4)<br> long(8)<br> double(8)<br> float(4)<br> boolean(1/8)<br> char(2)               </p>
<h3 id="（4）自动装箱，自动拆箱"><a href="#（4）自动装箱，自动拆箱" class="headerlink" title="（4）自动装箱，自动拆箱"></a>（4）自动装箱，自动拆箱</h3><p> 自动装箱：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Integer i&#x3D; 100； &#x2F;&#x2F; 基本类型自动装箱为包装类,编译器会优化为 Integer i &#x3D; new Integer(100);</span><br></pre></td></tr></table></figure>
<p> 自动拆箱</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">int i &#x3D;new Integer(100); &#x2F;&#x2F;编译集会优化为 int i  &#x3D;new Integer(100).intValue();</span><br></pre></td></tr></table></figure>
<h3 id="5-Integer-intValue"><a href="#5-Integer-intValue" class="headerlink" title="(5) Integer.intValue()"></a>(5) Integer.intValue()</h3><p>integer 定义的对象,范围在-128带127会被缓存起来，所以在这个范围内的integer进行判断相等会等于true，因为是同一对象</p>
<h3 id="6-和-equals-的区别"><a href="#6-和-equals-的区别" class="headerlink" title="(6) == 和 equals 的区别"></a>(6) == 和 equals 的区别</h3><p>1.== 是判断对象地址是否相等，equals没在重写的情况下也是判读对象地址等同于==<br>2.不通对象的地址是不一样的，如果相比较两个对象的内容是否一样则需重写equals方法</p>
<h3 id="7）hashcode-和-equals-的区别"><a href="#7）hashcode-和-equals-的区别" class="headerlink" title="(7）hashcode()和 equals()的区别"></a>(7）hashcode()和 equals()的区别</h3><p>  equals()必须满足一下几点：<br>1.自反性  a.equals(a) =true<br>2.对称性  a.equals(b) =true  b.equals(a) =true<br>3.一致性  a.equals(a) 多次调用永远等于true<br>4.对于null判断始终等于false<br>hashcode()的实现方式和操作系统有关,姑且认为是获取对象的地址。<br>重写equals()方法必须重写hashcode(),因为在hash数据结构添加数据的时候，需要先通过hashcode()方法查找存储的位置(链地址发),如果该位置不存在则插入，如果该位置已经拥有对象则,需要通过equals()方法判断对象是否相同，如果相同则替换，如果不通则在改对象后面进行存储。<br>1.两个相同的对象hashcode 必须相同,hashcode相同的对象,对象之间可能不通<br> 2. hashcode()不同,则对象也不相同</p>
<ul>
<li>如果之重写了equals()方法会出现什么效果？<br>答案：两个相同的对象hashcode不同,hashmap的key会放入相同的对象</li>
</ul>
<h3 id="8-String-amp-StringBuffer-amp-StringBuilder"><a href="#8-String-amp-StringBuffer-amp-StringBuilder" class="headerlink" title="(8) String &amp; StringBuffer &amp; StringBuilder"></a>(8) String &amp; StringBuffer &amp; StringBuilder</h3><ol>
<li>都是final的不可以被继承</li>
<li>String 不可变 StringBuffer,StringBuilder 长度可变</li>
<li>String 重写了equals()方法和hashcode()方法</li>
<li> StringBuffer 是线程安全的 StringBuilder是线程不安全的</li>
<li>在单线程下 StringBuffer和StringBuilder效率一样,再多线程下StringBuilder效率更高,因为StringBuffer在一些方法上加了同步synchronized 方式</li>
<li>字面直接声明的String 在编译期间都会优化为final声明的  </li>
</ol>
<h3 id="9-‘-’-和substring"><a href="#9-‘-’-和substring" class="headerlink" title="(9) ‘+’ 和substring()"></a>(9) ‘+’ 和substring()</h3><ol>
<li>‘+’ 和 substring() 都会生成一个新的对象</li>
<li>‘+’ 和 substring() 都是在在堆中生成的对象 (<strong>没有在常量池所以不共享</strong>)</li>
<li>‘+’ 在编译期间会被优化为 append()方法</li>
</ol>
<h3 id="10-可以手动创建java-long-String-类么？可以使用么？为什么？"><a href="#10-可以手动创建java-long-String-类么？可以使用么？为什么？" class="headerlink" title="(10) 可以手动创建java.long.String 类么？可以使用么？为什么？"></a>(10) 可以手动创建java.long.String 类么？可以使用么？为什么？</h3><ol>
<li>可以创建，但是不能被使用，因为类加载机制(双亲委派机制)</li>
<li>因为自定义的类的加载器为AppClassLoader.AppClassLoader加载器加载的时候需要先加载其父加载器,ExtClassLoader加载器,ExtClassLoader会在 jre/lib/ext 下去寻找 java.long.String 类, 此时找不到该类，则会调用ExtClassLoader的父加载器BootStrap加载器,在jre/lib下寻找,<br>最终找到String类并且加载</li>
<li>这也就是类加载的委托机制</li>
</ol>
]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>java基础</tag>
      </tags>
  </entry>
</search>
